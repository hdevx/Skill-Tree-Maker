<!DOCTYPE html>
<html>
  <head>
    <title>Skill Tree Maker | Drag and Drop Online Editor</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Instantly create your own skill trees, talent trees, and ability trees with this free online skill tree maker. Includes a drag and drop skill tree maker and a fantasy skills generator. Can be used as a skill tree maker for D&D, Pathfinder, and other RPGs."
    />
    <meta
      name="keywords"
      content="skill tree maker, RPG, skill tree, game design, skill tree generator, game development, RPG maker, character development, unique rpg classes, skill generator, skill tree maker online, rpg skill tree creator, rpg skill tree maker, dnd skill tree maker"
    />

    <meta name="robots" content="index, follow" />
    <meta name="author" content="RPG Skill Tree Generator" />

    <!-- Favicon -->
    <link rel="shortcut icon" type="image/x-icon" href="/icons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png" />
    <link rel="manifest" href="/icons/site.webmanifest" />
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebPage",
        "name": "RPG Skill Tree Designer",
        "image": "https://www.rpgskilltreegenerator.com/icons/android-chrome-512x512.png",
        "url": "https://www.rpgskilltreegenerator.com/",
        "description": "Type a class idea, like Holy Necromancer or Garlic Knight, and get an RPG skill tree with JSON export."
      }
    </script>

    <!-- Open Graph Meta Tags (for social media) -->
    <meta property="og:title" content="RPG Skill Tree Designer" />
    <meta
      property="og:description"
      content="Talent, Class, and Ability Tree Generator and Editor."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.rpgskilltreegenerator.com/" />
    <meta
      property="og:image"
      content="https://www.rpgskilltreegenerator.com/icons/android-chrome-512x512.png"
    />

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="RPG Skill Tree Designer" />
    <meta
      name="twitter:description"
      content="Talent, Class, and Ability Tree Generator and Editor."
    />
    <meta
      name="twitter:image"
      content="https://www.rpgskilltreegenerator.com/icons/android-chrome-512x512.png"
    />

    <script src="/lib/vue.global.js"></script>
    <style>
      body {
        background: #000000;
        padding: 0;
        margin: 0;
      }

      .talent-tree {
        background: linear-gradient(rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.85)),
          url("/img/background/grass-ancient.jpg");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        height: calc(100vh);
        user-select: none;
        /* Prevent text selection during panning */
        position: relative;
        overflow: hidden;
        /* padding: 20px; */
        opacity: 0;
        filter: blur(10px);
        transition: opacity 0.5s ease, filter 0.5s ease, background-image 0.5s ease;
        touch-action: none;
        /* Prevents browser handling of touch events */
        -webkit-touch-callout: none;
        /* Prevents iOS callout on long press */
        -webkit-user-select: none;
        /* Prevents text selection on iOS */
      }

      .talent-tree.loaded {
        opacity: 1;
        filter: blur(0);
      }

      .skill {
        position: absolute;
        width: 60px;
        height: 60px;
        background: #2a2a2a;
        border: 2px solid #292929;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        /* transition: all 0.3s ease; */
        transform: translate3d(0, 0, 0);
        will-change: transform;
        z-index: 1;
        touch-action: none;
        -webkit-tap-highlight-color: transparent;
        /* Removes tap highlight on iOS */
      }

      .skill:hover img {
        filter: brightness(1.7);
        box-shadow: 0 0 15px rgb(189, 122, 0);
      }

      /* Add touch device styles */

      .skill:focus img,
      .skill:active img {
        filter: brightness(1.7);
        box-shadow: 0 0 15px rgb(189, 122, 0);
      }

      .square-skills .skill,
      .square-skills .skill img,
      .square-skills .skill-preview,
      .square-skills .skill-preview img,
      .square-skills .image-option {
        border-radius: 0px !important;
      }

      .diamond-skills .skill,
      .diamond-skills .skill img,
      .diamond-skills .skill-preview,
      .diamond-skills .skill-preview img,
      .diamond-skills .image-option {
        border-radius: 4px;
        transform: rotate(45deg) !important;
      }

      /* Add this to keep the skill content straight */
      .diamond-skills .skill img,
      .diamond-skills .skill-preview img {
        /* transform: rotate(-45deg); */
      }

      .diamond-skills .skill .skill-points {
        transform: rotate(-45deg) !important;
        bottom: -25px;
        left: 90%;
      }

      .diamond-skills .skill-tooltip {
        transform: rotate(-45deg) !important;
      }

      .hexagon-skills .skill {
        clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        border-radius: 0px !important;
      }
      .hexagon-skills .skill img {
        clip-path: polygon(
          50% 1px,
          calc(100% - 5px) 25%,
          calc(100% - 5px) 75%,
          50% calc(100% - 5px),
          5px 75%,
          5px 25%
        ) !important;
        border-radius: 0;
      }

      .skill-actions {
        position: absolute;
        display: flex;
        gap: 10px;
        top: -40px;
        left: 50%;

        transform: translateX(-50%);
        z-index: 2;
      }

      .action-btn {
        background: #3498db;
        border: none;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        color: white;
        background: rgba(26, 26, 26, 0.95);
        padding: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        position: relative;
        touch-action: manipulation;
        /* Optimize for touch */
        -webkit-tap-highlight-color: transparent;
      }

      .action-btn-tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        white-space: nowrap;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        margin-bottom: 5px;
        z-index: 9998;
      }

      .connection {
        position: absolute;
        background: #3498db;
        height: 10px;
        transform-origin: left center;
        background: #4a4a4a;
        /* More subtle connection line */
        box-shadow: 0 0 5px rgba(74, 74, 74, 0.5);
        transition: background 0.25s ease;
      }

      .connection-after {
        content: "";
        position: absolute;
        right: 31px;
        /* This makes arrow slide up and down */
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border-left: 10px solid #4a4a4a;
        /* Increased to 20px for larger arrow */
        border-top: 5px solid transparent;
        /* Increased to 10px for proportional width */
        border-bottom: 5px solid transparent;
        /* Increased to 10px for proportional width */
        transition: border-left-color 0.25s ease;
      }

      .connection.active .connection-after {
        border-left-color: #ffd700;
      }

      .connection.connection-hover .connection-after {
        border-left-color: #ff4747;
      }

      .view-mode .connection.connection-hover {
        background: #4a4a4a;
        box-shadow: none;
      }

      .view-mode .connection.connection-hover .connection-after {
        border-left-color: #4a4a4a;
      }

      .view-mode .connection-hitbox {
        cursor: default;
      }

      .connection.active {
        background: #ffd700;
        /* Golden/yellow color for active connections */
        box-shadow: 0 0 5px rgba(255, 215, 0, 0.9);
      }

      .skill-tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.95);
        color: #ffd100;
        padding: 10px;
        border-radius: 4px;
        font-size: 14px;
        width: 320px;
        pointer-events: none;
        z-index: 1000;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        font-family: Verdana, sans-serif;
        border: 1px solid #4a4a4a;
        transform: translateZ(0);
        will-change: transform;
      }

      .skill-tooltip.tooltip-left {
        right: calc(100% + 10px);
        top: calc(50% + 23px);
        transform: translateY(-50%);
      }

      .skill-tooltip.tooltip-right {
        left: calc(100% + 10px);
        top: calc(50% + 23px);
        transform: translateY(-50%);
      }

      /* Add this media query for mobile devices */
      @media (max-width: 768px) {
        .skill-tooltip {
          width: 200px;
          font-size: 12px;
          top: calc(50% + 43px) !important;
        }

        /* Add mobile styles for skills */
        .skill {
          width: 45px;
          /* Smaller skill icons on mobile */
          height: 45px;
        }

        /* Adjust class title for mobile */
        .class-title {
          font-size: 1rem !important;
          /* bottom: 10px; */
          bottom: 57px !important;
          width: 60%;
          width: 40vw;
          /* white-space: nowrap; */
          /* overflow: hidden; */
          /* text-overflow: ellipsis; */
        }

        /* Adjust generate controls for mobile */
        .generate-controls {
          width: 80%;
          /* Reduced from 90% */
          padding: 8px;
          /* Reduced from 15px */
          gap: 5px;
          /* Reduced from 10px */
          flex-direction: column;
          /* Stack input above buttons */
        }

        .generate-input {
          width: calc(100% - 18px);
          padding: 8px;
          font-size: 14px;
        }

        /* Add a container div for buttons */
        .button-container {
          display: flex;
          width: 100%;
          gap: 5px;
        }

        .generate-btn {
          width: 80%;
          /* Take up 80% of the space */
          padding: 8px;
          font-size: 14px;
          top: 0px !important;
        }

        .random-generate-btn {
          width: 20%;
          /* Take up 20% of the space */
          padding: 8px;
          font-size: 14px;
          margin-top: 0px !important;
        }

        .skill-preview-container {
          flex: 0 0 30px !important;
          /* Fixed width for preview section */
        }

        .skill-preview::after {
          content: "Tap to change image";
          /* Change text for mobile */
          top: -35px;
          /* Adjust position for mobile */
          font-size: 11px;
          /* Smaller font size for mobile */
          padding: 3px 8px;
          /* Smaller padding for mobile */
        }

        /* Show tooltip briefly on mobile tap */
        .skill-preview::after {
          opacity: 1 !important;
          background-color: #00000000;
        }
      }

      .skill-tooltip h3 {
        margin: 0 0 5px 0;
        color: #ffffff;
        /* White title */
        font-size: 15px;
        font-weight: bold;
        border-bottom: 1px solid #4a4a4a;
        padding-bottom: 5px;
      }

      .skill-tooltip p {
        margin: 5px 0;
        font-size: 12px;
        color: #ffd100;
        /* Description in golden yellow */
        line-height: 1.4;
      }

      .skill-tooltip .damage {
        color: #ff4747;
        /* Brighter red for damage */
        font-weight: normal;
        margin-top: 8px;
      }

      .skill-points {
        position: absolute;
        bottom: -22px;
        left: 50%;
        font-family: Verdana, sans-serif;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 2px 6px;
        border-radius: 10px;
        font-size: 12px;
        white-space: nowrap;
      }

      .skill img {
        filter: brightness(1);
        transition: all 0.2s ease;
      }

      .skill.inactive img {
        filter: grayscale(100%) brightness(0.9);
      }

      .options-button {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: rgba(26, 26, 26, 0.95);
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        z-index: 1000;
      }

      .options-panel {
        position: fixed;
        bottom: 70px;
        left: 20px;
        background: rgba(26, 26, 26, 0.95);
        padding: 15px;
        border-radius: 8px;
        color: white;
        z-index: 1000;
        font-family: Verdana, sans-serif;
        margin-right: 20px;

        animation: panelFadeIn 0.3s ease forwards;
        font-size: 14px;
      }

      /* Add keyframes for fade in/out */
      @keyframes panelFadeIn {
        from {
          opacity: 0;
          transform: scale(0.95) translateY(10px);
        }

        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      .options-panel label {
        display: block;
        margin-bottom: 5px;
      }

      .options-panel input {
        width: 100px;
        margin-bottom: 10px;
      }

      .options-panel label {
        display: block;
        margin-bottom: 5px;
        color: #ffd100;
        /* Added golden color to match theme */
      }

      .options-panel input {
        width: 200px;
        /* Increased width for better visibility */
        margin-bottom: 10px;
        padding: 8px;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #4a4a4a;
        border-radius: 4px;
        color: #ffffff;
        font-family: Verdana, sans-serif;
      }

      .options-panel input:focus {
        outline: none;
        border-color: #ffd100;
      }

      @keyframes skillIntro {
        0% {
          opacity: 0;
          transform: scale(0.3) translateY(20px);
        }

        100% {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      .skill {
        /* ... existing skill styles ... */
        opacity: 1;
        transform: scale(1);
      }

      .skill.animate-in {
        animation: skillIntro 0.6s cubic-bezier(0.17, 0.89, 0.32, 1.28) forwards;
      }

      .skill.skilled {
        border: 2px solid #ffd700;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.9);
      }

      .btn {
        background: #3498db;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 8px 12px;
        cursor: pointer;
        width: 100%;
        margin-top: 10px;
      }

      .btn {
        /* background: #3498db; */
        background: rgba(74, 74, 74, 0.7);
        color: #ffd100;
        /* color: white; */
        border: none;
        border-radius: 4px;
        padding: 8px 12px;
        cursor: pointer;
        width: 100%;
        margin-top: 10px;
      }

      .btn:hover {
        background: #2980b9;
      }

      .edit-modal-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
      }

      .edit-modal {
        display: flex;
        /* Add this */
        gap: 20px;
        /* Add this */
        background: rgba(16, 16, 16, 0.95);
        border: 1px solid #4a4a4a;
        border-radius: 8px;
        padding: 20px;
        width: 90%;
        max-width: 600px;
        /* Increased from 500px to accommodate preview */
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
        color: #ffd100;
        font-family: Verdana, sans-serif;
        margin-left: 7%;
        margin-right: 7%;
      }

      /* Add new styles for the preview section */
      .skill-preview-container {
        flex: 0 0 100px;
        /* Fixed width for preview section */
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }

      .skill-preview {
        width: 60px;
        height: 60px;
        background: #2a2a2a;
        border: 2px solid #292929;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        top: 44px;
        position: relative;
        /* Add this */
      }

      .skill-preview::after {
        content: "Click to swap image";
        position: absolute;
        bottom: -45px;
        /* Position below the skill points counter */
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: #ffd100;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .skill-preview:hover::after {
        opacity: 1;
      }

      .skill-preview.skilled {
        border: 2px solid #ffd700;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.9);
      }

      .skill-preview img {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        object-fit: cover;
      }

      .skill-preview .skill-points {
        position: absolute;
        bottom: -22px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 2px 6px;
        border-radius: 10px;
        font-size: 12px;
        white-space: nowrap;
      }

      .edit-form-container {
        flex: 1;
        /* Take remaining space */
      }

      .edit-modal h2 {
        color: #ffffff;
        text-align: center;
        margin: 0 0 20px 0;
        padding-bottom: 10px;
        border-bottom: 1px solid #4a4a4a;
        font-size: 18px;
      }

      .edit-field {
        margin-bottom: 15px;
      }

      .edit-field label {
        display: block;
        margin-bottom: 5px;
        color: #ffd100;
        font-size: 14px;
      }

      .edit-field input,
      .edit-field textarea {
        width: 100%;
        padding: 8px 12px;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #4a4a4a;
        border-radius: 4px;
        color: #ffffff;
        font-family: Verdana, sans-serif;
        font-size: 14px;
        transition: border-color 0.2s ease;
      }

      .edit-field textarea {
        height: 100px;
        resize: vertical;
      }

      .edit-field input:focus,
      .edit-field textarea:focus {
        outline: none;
        border-color: #ffd100;
      }

      .edit-modal-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
      }

      .edit-modal-button {
        padding: 8px 20px;
        border: none;
        border-radius: 4px;
        font-family: Verdana, sans-serif;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .save-button {
        background: #4a4a4a;
        color: #ffd100;
      }

      .save-button:hover {
        background: #5a5a5a;
        box-shadow: 0 0 10px rgba(255, 209, 0, 0.3);
      }

      .cancel-button {
        background: #2a2a2a;
        color: #ffffff;
      }

      .cancel-button:hover {
        background: #3a3a3a;
      }

      .skill:hover {
        z-index: 100;
      }

      .random-btn {
        background: #2ecc71;
        /* Green color */
        color: white;
        border: none;
        border-radius: 4px;
        padding: 8px 12px;
        cursor: pointer;
        width: 100%;
        margin-top: 10px;
        transition: background-color 0.2s ease;
      }

      .random-btn:hover {
        background: #27ae60;
        /* Darker green on hover */
      }

      .skill:hover .skill-tooltip {
        z-index: 1000;
      }

      .skill.active img {
        filter: brightness(1.7);
        box-shadow: 0 0 15px rgb(189, 122, 0);
      }

      .class-title {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: #ffd100;
        font-family: Verdana, sans-serif;
        font-size: 24px;
        text-align: center;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        z-index: 1;
        padding: 10px 20px;
        border-radius: 8px;
        pointer-events: none;
        font-family: "Rocher", serif;
        opacity: 0;
        animation: slideUp 0.5s ease 1s forwards;
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(20px);
        }

        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      /* FONT */
      @font-face {
        font-family: "Rocher";
        src: url("/css/RocherColorGX.woff2");
      }

      .generate-controls {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        display: flex;
        gap: 10px;
        align-items: center;
        background: rgba(26, 26, 26, 0.95);
        padding: 15px;
        border-radius: 8px;
        width: 90%;
        max-width: 600px;
        border: 1px solid #4a4a4a;
        animation: slideDown 0.5s ease 1s both;
      }

      @keyframes slideDown {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(20px);
        }

        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      .generate-input {
        flex: 1;
        padding: 12px;
        border: 1px solid #4a4a4a;
        border-radius: 4px;
        background: rgba(0, 0, 0, 0.7);
        color: #ffd100;
        font-family: "Rocher", serif;
        font-size: 16px;
      }

      .generate-input:focus {
        outline: none;
        border-color: #ffd100;
        box-shadow: 0 0 10px rgba(255, 209, 0, 0.3);
      }

      .generate-btn {
        background: #4a4a4a;
        color: #ffd100;
        border: none;
        padding: 12px 24px;
        border-radius: 4px;
        cursor: pointer;
        white-space: nowrap;
        font-family: "Rocher", serif;
        font-size: 16px;
        transition: all 0.2s ease;
        top: -4px;
      }

      .generate-btn:hover {
        background: #5a5a5a;
        box-shadow: 0 0 10px rgba(255, 209, 0, 0.3);
      }

      .generate-btn:disabled {
        background: #2a2a2a;
        color: #666;
        cursor: not-allowed;
        box-shadow: none;
      }

      .history-controls {
        position: fixed;
        bottom: 20px;
        right: 20px;
        display: flex;
        gap: 10px;
        z-index: 1000;
      }

      .history-btn {
        background: rgba(26, 26, 26, 0.95);
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        opacity: 0.7;
        transition: opacity 0.2s ease;
      }

      .history-btn:hover {
        opacity: 1;
      }

      .history-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      @media (max-width: 768px) {
        .generate-controls {
          width: 80%;
          /* Reduced from 90% */
          padding: 8px;
          /* Reduced from 15px */
          gap: 5px;
          /* Reduced from 10px */
          flex-direction: column;
          /* Stack input above buttons */
        }

        .generate-input {
          width: calc(100% - 18px);
          padding: 8px;
          font-size: 14px;
        }

        /* Add a container div for buttons */
        .button-container {
          display: flex;
          width: 100%;
          gap: 5px;
        }

        .generate-btn {
          width: 80%;
          /* Take up 80% of the space */
          padding: 8px;
          font-size: 14px;
          top: 0px;
        }

        .random-generate-btn {
          width: 20%;
          /* Take up 20% of the space */
          padding: 8px;
          font-size: 14px;
          margin-top: 0px;
          margin-left: 0px !important;
        }
      }

      .random-generate-btn {
        background: rgba(74, 74, 74, 0.7);
        color: #ffd100;
        border: none;
        padding: 12px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-family: "Rocher", serif;
        font-size: 20px;
        transition: all 0.2s ease;
        opacity: 0.8;
        margin-left: 8px;
        margin-top: 3px;
      }

      .random-generate-btn:hover {
        background: rgba(90, 90, 90, 0.8);
        opacity: 1;
        box-shadow: 0 0 10px rgba(255, 209, 0, 0.2);
      }

      .random-generate-btn:disabled {
        background: #2a2a2a;
        color: #666;
        cursor: not-allowed;
        box-shadow: none;
        opacity: 0.5;
      }

      /* Update generate-controls to accommodate the new button */
      .generate-controls {
        gap: 8px;
        /* Reduced from 10px to tighten spacing */
      }

      /* Ensure mobile responsiveness */
      @media (max-width: 768px) {
        .random-generate-btn {
          padding: 8px 12px;
          font-size: 16px;
        }
      }

      .generate-tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        white-space: nowrap;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        margin-bottom: 5px;
        z-index: 9998;
      }

      .image-selector-modal {
        position: fixed;
        top: 50%;
        left: 43%;
        transform: translate(-50%, -50%) scale(0.9);
        background: rgba(16, 16, 16, 0.98);
        border: 1px solid #4a4a4a;
        border-radius: 8px;
        padding: 20px;
        width: 80%;
        margin-left: 7%;
        margin-right: 7%;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        z-index: 11000;
        opacity: 0;
        transition: all 0.3s ease;
        min-height: 350px;
      }

      .image-selector-modal.active {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }

      .image-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 15px;
        padding: 15px;
      }

      .image-option {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: 2px solid #292929;
        cursor: pointer;
        transition: all 0.2s ease;
        -webkit-tap-highlight-color: transparent;
        margin-bottom: 15px;
      }

      .image-option:hover {
        border-color: #ffd700;
        transform: scale(1.1);
      }

      .image-option.selected {
        border-color: #ffd700;
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
      }

      .image-selector-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
      }

      .generate-input {
        position: relative;
      }

      .generate-btn,
      .random-generate-btn {
        position: relative;
      }

      .edit-field {
        margin-bottom: 15px;
      }

      .edit-field.row {
        display: flex;
        gap: 10px;
        justify-content: space-between;
      }

      .edit-field.row > div {
        flex: 1;
        min-width: 0;
        /* Prevents flex items from overflowing */
      }

      .edit-field input,
      .edit-field textarea {
        width: calc(100% - 24px);
        /* Adjust for padding */
        box-sizing: border-box;
        /* Include padding in width calculation */
      }

      .edit-field.row input {
        width: 100%;
        /* Full width within its container */
      }

      /* Add or update these styles */
      @media (max-width: 768px) {
        .edit-modal h2 {
          font-size: 16px;
          /* Smaller title on mobile */
          margin: 0 0 15px 0;
        }

        .edit-field label {
          font-size: 12px;
          /* Smaller labels */
        }

        .edit-field input,
        .edit-field textarea {
          font-size: 12px;
          /* Smaller input text */
          padding: 6px 10px;
          /* Slightly smaller padding */
        }

        .skill-preview-container {
          margin-top: 20px;
          /* Move preview down on mobile */
        }

        .edit-modal-button {
          font-size: 12px;
          /* Smaller button text */
          padding: 6px 16px;
          /* Slightly smaller padding */
        }
      }

      .edit-field.row {
        display: flex;
        gap: 10px;
        justify-content: space-between;
      }

      .edit-field.row > div {
        flex: 1;
        min-width: 0;
        /* Prevents flex items from overflowing */
        display: flex;
        /* Add this */
        flex-direction: column;
        /* Add this */
        align-items: flex-start;
        /* Add this */
      }

      .edit-field.row label {
        margin-bottom: 5px;
        /* Add consistent spacing below labels */
        min-height: 1.2em;
        /* Add this to ensure consistent height */
        width: 100%;
        /* Add this to ensure full width */
        position: relative;
        /* Add this one line */
      }

      .edit-field.row input {
        width: 100%;
        margin-top: auto;
        /* Add this to push inputs to bottom */
      }

      .skill-preview {
        position: relative;
        /* Add this */
      }

      .skill-preview::after {
        content: "Tap to Swap";
        position: absolute;
        top: -35px;
        /* Position below the skill points counter */
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0);
        color: #ffd100;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s ease;
        /* animation: slideDown 0.5s ease 1s both; */
      }

      .skill-preview:hover::after {
        opacity: 1;
      }

      .skill-preview.hide-tooltip::after {
        display: none;
      }

      .share-btn {
        background: #3498db;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 8px 12px;
        cursor: pointer;
        width: 100%;
        margin-top: 10px;
        transition: background-color 0.2s ease;
      }

      .share-btn:hover {
        background: #2980b9;
      }

      .share-btn .action-btn-tooltip {
        margin-left: 50px;
      }

      .share-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(16, 16, 16, 0.98);
        border: 1px solid #4a4a4a;
        border-radius: 8px;
        padding: 20px;
        z-index: 10001;
        color: #ffd100;
        text-align: center;
        font-family: "Rocher", serif;
        width: 70%;
      }

      /* Add new styles for the close button */
      .share-modal .close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        color: #ffd100;
        cursor: pointer;
        font-size: 18px;
        padding: 5px;
        opacity: 0.8;
        transition: opacity 0.2s ease;
      }

      .share-modal .close-btn:hover {
        opacity: 1;
      }

      .share-link {
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
        word-break: break-all;
      }

      .copy-btn {
        background: #4a4a4a;
        color: #ffd100;
        border: none;
        padding: 8px 20px;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 10px;
      }

      .copy-btn:hover {
        background: #5a5a5a;
      }

      /* Add new styles for the button container */
      @media (min-width: 768px) {
        .bottom-left-buttons {
          position: fixed;
          bottom: 20px;
          left: 20px;
          display: flex;
          gap: 10px;
          z-index: 1000;
        }

        /* Update the options-button style to match other buttons */
        .options-button,
        .share-button,
        .download-button {
          background: rgba(26, 26, 26, 0.95);
          border: none;
          border-radius: 50%;
          width: 40px;
          height: 40px;
          color: white;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 20px;
          transition: opacity 0.2s ease;
        }

        .options-button:hover,
        .share-button:hover,
        .download-button:hover {
          opacity: 0.8;
        }

        .download-button,
        .share-button,
        .discord-button {
          /* display: flex; */
          position: absolute;
          top: -39px;
        }

        .download-button {
          left: 50;
        }

        .share-button {
          left: 100px;
        }

        .discord-button {
          left: 150px;
        }
      }

      @media (max-width: 768px) {
        .download-button,
        .share-button {
          display: none !important;
        }

        .discord-button {
          left: 70px;
          bottom: 20px;
          position: absolute;
        }

        .points-display {
          /* left: 10px; */
          bottom: 60px !important;
          right: 24px !important;
          position: absolute;
        }
      }

      .image-upload-section {
        padding: 15px;
        border-bottom: 1px solid #4a4a4a;
        text-align: center;
      }

      .upload-button {
        display: inline-block;
        background: #4a4a4a;
        color: #ffd100;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .upload-button:hover {
        background: #5a5a5a;
        box-shadow: 0 0 10px rgba(255, 209, 0, 0.3);
      }

      .upload-info {
        color: #999;
        font-size: 12px;
        margin-top: 8px;
      }

      .discord-button {
        background: rgba(26, 26, 26, 0.95);
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        /* padding-left: 20px; */
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        transition: opacity 0.2s ease;
        margin-left: 0px;
      }

      .discord-button img {
        /* margin-left: 10px; */
        width: 24px;
        height: 24px;
      }

      .discord-button:hover {
        opacity: 0.8;
      }

      /* Add new styles for the load button */
      .load-button {
        background: rgba(26, 26, 26, 0.95);
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        transition: opacity 0.2s ease;
        position: absolute;
        top: -39px;
        left: 200px;
      }

      .load-button:hover {
        opacity: 0.8;
      }

      @media (max-width: 768px) {
        .load-button {
          display: none;
        }
      }

      /* @media (max-width: 768px) {
            .bottom-left-buttons {
                display: flex;
                gap: 10px;
            }
        } */

      #resources-container {
        max-height: 150px;
        overflow-y: auto;
      }

      #resources-container .row {
        gap: 5px;
        margin-bottom: 5px;
      }

      #resources-container button {
        background: none;
        border: none;
        color: #ff4747;
        cursor: pointer;
      }

      .add-resource {
        background: rgba(0, 0, 0, 0);
        color: #ffd100;
        color: #777;
        border: none;
        padding: 5px;
        border-radius: 4px;
        cursor: pointer;
        width: 100%;
        margin-top: 5px;
      }

      .skill-tooltip .resources-container {
        display: flex;
        flex-direction: column;
        gap: 3px;
        margin: 0px 0;
        /* border-top: 1px solid #4a4a4a; */
        /* padding-top: 5px; */
      }

      .skill-tooltip .resource-row {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
      }

      /* Add hover state */
      .connection.connection-hover {
        background: #ff4747;
        /* Red color on hover to indicate deletion */
        box-shadow: 0 0 8px rgba(255, 71, 71, 0.7);
      }

      /* Invisible wider hit area */
      .connection-hitbox {
        position: absolute;
        top: -8px;
        /* Extend 8px above */
        bottom: -8px;
        /* Extend 8px below */
        left: 0;
        right: 0;
        cursor: pointer;
      }

      .edit-resource-row {
        cursor: move;
        /* padding: 4px; */
        user-select: none;
      }

      .edit-resource-row:active {
        opacity: 0.8;
        background: rgba(74, 74, 74, 0.4);
      }

      .grid-overlay {
        /* position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0; */
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
      }

      .grid-line {
        position: absolute;
        background-color: rgba(255, 255, 255, var(--grid-opacity));
      }

      .grid-line.horizontal {
        width: 100%;
        height: 1px; /*increase to 2px to avoid missing lines when zooming out   */
      }

      .grid-line.vertical {
        height: 100%;
        width: 1px;
      }

      .points-display {
        position: fixed;
        bottom: 20px;
        right: 125px;
        /* Position before undo/redo buttons */
        /* background: rgba(26, 26, 26, 0.95); */
        color: #ffd100;
        padding: 8px 15px;
        border-radius: 4px;
        font-family: "Rocher", serif;
        z-index: 1000;
        border: 1px solid #4a4a4a;
      }

      @media (max-width: 768px) {
        .points-display {
          font-size: 12px;
          padding: 6px 10px;
          right: 123px;
          bottom: 24px;
        }
      }

      .toast-notification {
        position: fixed;
        bottom: 70px;
        /* left: 50%; */
        right: 20px;
        transform: translateX(0%) translateY(50%);
        background: rgba(26, 26, 26, 0.95);
        color: #ffd100;
        padding: 12px 24px;
        border-radius: 8px;
        font-family: "Rocher", serif;
        z-index: 10000;
        border: 1px solid #4a4a4a;
        opacity: 0;
        transition: all 0.3s ease;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .toast-notification.show {
        transform: translateX(0%) translateY(0%);
        opacity: 1;
      }

      .range-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 10px 0;
      }

      input[type="range"] {
        /* -webkit-appearance: none; */
        width: 100px;
        /* height: 2px; */
        /* background: rgba(255, 209, 0, 0.2); */
        /* border-radius: 2px; */
      }

      /* 
input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 12px;
    height: 12px;
    background: #ffd100;
    border-radius: 50%;
    cursor: pointer;
    transition: transform 0.2s;
}

input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.2);
} */

      .options-panel {
        position: fixed;
        bottom: 70px;
        left: 20px;
        background: rgba(26, 26, 26, 0.95);
        padding: 20px;
        border-radius: 8px;
        color: white;
        z-index: 1000;
        font-family: Verdana, sans-serif;
        margin-right: 20px;
        animation: panelFadeIn 0.3s ease forwards;
        font-size: 14px;
        max-height: 75vh;
        overflow-y: auto;
        border: 1px solid #4a4a4a;
        /* min-width: 280px; */
        width: 370px;
      }

      .options-section {
        /* border: 1px solid #4a4a4a; */
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 15px;
        background: rgba(0, 0, 0, 0.2);
      }

      .options-section:last-child {
        margin-bottom: 0;
      }

      .options-section h3 {
        color: #ffd100;
        margin: 0 0 15px 0;
        font-size: 16px;
        border-bottom: 1px solid #4a4a4a;
        padding-bottom: 8px;
        font-family: Verdana, sans-serif;
        font-weight: 300;
      }

      .option-group {
        margin-bottom: 12px;
      }

      .option-group:last-child {
        margin-bottom: 0;
      }

      .option-group label {
        display: block;
        color: #ffd100;
        margin-bottom: 6px;
        font-size: 14px;
      }

      .option-group input[type="text"],
      .option-group input[type="number"] {
        width: 90%;
        padding: 8px;
        background: rgba(0, 0, 0, 0.3);
        /* border: 1px solid #4a4a4a; */
        border-radius: 4px;
        color: white;
      }

      .option-group select {
        width: 90%;
        padding: 8px;
        background: rgb(0, 0, 0);
        border: 1px solid #4a4a4a;
        border-radius: 4px;
        color: white;
      }

      .color-controls,
      .range-container,
      .grid-controls,
      .snap-controls {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .color-controls input[type="color"] {
        width: 40px;
        height: 30px;
        padding: 0;
        border: 1px solid #4a4a4a;
      }

      .color-controls input[type="range"] {
        flex: 1;
      }

      .button-group {
        display: flex;
        gap: 10px;
      }

      .button-group .btn {
        flex: 1;
      }

      /* Checkbox styling */
      .option-group input[type="checkbox"] {
        margin-right: 8px;
        width: auto;
      }

      /* Range input styling */
      .option-group input[type="range"] {
        width: 100%;
        margin: 8px 0;
      }

      @media (max-width: 768px) {
        .options-panel {
          max-height: 70vh;
          /* width: 81vw; */
          width: calc(100vw - 100px);
        }
      }

      /* Update modal styles */
      .load-modal-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        /* background: rgba(0, 0, 0, 0.85); */
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .load-modal-backdrop.active {
        opacity: 1;
      }

      .load-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.9);
        background: rgba(16, 16, 16, 0.98);
        border: 1px solid #4a4a4a;
        border-radius: 8px;
        padding: 20px;
        z-index: 11000;
        color: #ffd100;
        text-align: center;
        font-family: "Rocher", serif;
        width: 70%;
        max-width: 400px;
        opacity: 0;
        transition: all 0.3s ease;
      }

      .load-modal.active {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }

      .recent-backgrounds {
        display: flex;
        gap: 10px;
        margin-top: 10px;
      }

      .background-thumbnail {
        width: 60px;
        height: 40px;
        border-radius: 4px;
        background-size: cover;
        background-position: center;
        cursor: pointer;
        border: 1px solid #4a4a4a;
        transition: all 0.2s ease;
      }

      .background-thumbnail:hover {
        border-color: #ffd100;
        transform: scale(1.05);
      }

      .selection-box {
        position: absolute;
        border: 1px solid #ffd100;
        background: rgba(255, 209, 0, 0.1);
        pointer-events: none;
        z-index: 1;
      }

      .zoom-tree {
        position: relative;
        transform: translate(-25%, -25%) scale(1);
        transform-origin: center center;
        width: 200%;
        height: 200%;

        pointer-events: none;
      }
      .zoom-tree .skill-connections-container {
        pointer-events: auto;
      }
    </style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GBBGRRLHZC"></script>
    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6633346106464623"
      crossorigin="anonymous"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-GBBGRRLHZC");
    </script>

    <script type="text/javascript">
      (function (c, l, a, r, i, t, y) {
        c[a] =
          c[a] ||
          function () {
            (c[a].q = c[a].q || []).push(arguments);
          };
        t = l.createElement(r);
        t.async = 1;
        t.src = "https://www.clarity.ms/tag/" + i;
        y = l.getElementsByTagName(r)[0];
        y.parentNode.insertBefore(t, y);
      })(window, document, "clarity", "script", "pezds8guu2");
    </script>
  </head>

  <body>
    <div id="app">
      <div class="generate-controls">
        <input
          type="text"
          v-model="inputText"
          placeholder="Enter a class idea..."
          class="generate-input"
          @keyup.enter="handleEnterKey"
          @mouseenter="showGenerateTooltip($event, 'Type a class idea like \'Holy Necromancer\' or \'Garlic Knight\'')"
          @mouseleave="hideGenerateTooltip($event)"
        />
        <div class="button-container">
          <button
            class="generate-btn"
            @click="generateTreeFromPrompt"
            :disabled="isLoading"
            @mouseenter="showGenerateTooltip($event, 'Generate a new skill tree based on your prompt. You can also type instructions.')"
            @mouseleave="hideGenerateTooltip($event)"
          >
            {{ isLoading ? 'Generating...' : 'Generate Skills' }}
          </button>
          <button
            class="random-generate-btn"
            @click="generateRandomTree"
            :disabled="isLoading"
            @mouseenter="showGenerateTooltip($event, 'Try a Random Example')"
            @mouseleave="hideGenerateTooltip($event)"
          >
            ðŸŽ²
          </button>
        </div>
      </div>
      <div
        class="talent-tree"
        @click="handleClick"
        @mousedown="startPan"
        @wheel="handleZoom"
        @touchstart="handleTreeTouchStart"
        @touchmove.prevent="handleTreeTouchMove"
        @touchend="handleTreeTouchEnd"
        @contextmenu.prevent
      >
        <div class="zoom-tree">
          <div v-if="showGlobalGrid" class="grid-overlay" :style="gridStyle">
            <!-- Grid lines will be added dynamically -->
            <div
              v-for="line in gridLines"
              :key="line.id"
              class="grid-line"
              :class="line.type"
              :style="line.style"
            ></div>
          </div>
          <div
            v-if="selectionBox"
            class="selection-box"
            :style="{
                left: `${Math.min(selectionBox.x, selectionBox.x + selectionBox.width)}px`,
                top: `${Math.min(selectionBox.y, selectionBox.y + selectionBox.height)}px`,
                width: `${Math.abs(selectionBox.width)}px`,
                height: `${Math.abs(selectionBox.height)}px`
            }"
          ></div>

          <div class="skill-connections-container">
            <!-- Connections between skills -->
            <div
              v-for="connection in connections"
              :key="connection.id"
              class="connection"
              :class="{ active: isConnectionActive(connection), 'connection-hover': connection.isHovered }"
              :style="getConnectionStyle(connection)"
              @mouseenter="connection.isHovered = true"
              @mouseleave="connection.isHovered = false"
              @click.stop="removeConnection(connection)"
              @touchstart.stop.prevent="removeConnection(connection)"
            >
              <div class="connection-hitbox"></div>
              <div v-show="showArrows" class="connection-after"></div>
            </div>

            <!-- Skills -->
            <div
              v-for="(skill, index) in skills"
              :key="skill.id"
              :data-skill-id="skill.id"
              class="skill"
              :class="{
                        'inactive': skill.currentPoints === 0,
                        'animate-in': skill.shouldAnimate,
                        'initial-skill': index < 4,
                        'skilled': skill.currentPoints > 0
                        //'selected': selectedSkills.includes(skill.id)'
                    }"
              :style="{
                        left: skill.x + 'px',
                        top: skill.y + 'px',
                        opacity: skill.shouldAnimate ? 1 : 0
                    }"
              @contextmenu.prevent="decrementPoints(skill)"
              @click.stop="!$event.shiftKey && toggleActions(skill)"
              @mousedown.left="startDrag($event, skill)"
              @touchstart.stop="handleSkillTouch($event, skill)"
              @touchend.stop="handleSkillTouchEnd(skill)"
              @mouseenter="skill.showTooltip = true"
              @mouseleave="skill.showTooltip = false"
              @click.shift.stop="toggleSkillSelection(skill)"
            >
              <img
                :src="skill.image"
                :alt="skill.name"
                @load="handleImageLoad($event)"
                style="
                  width: 100%;
                  height: 100%;
                  border-radius: 50%;
                  object-fit: cover;
                  color: transparent;
                  opacity: 0;
                  transition: opacity 0.3s ease;
                "
              />
              <div class="skill-points">{{ skill.currentPoints }}/{{ skill.maxPoints }}</div>

              <!-- Add the tooltip -->
              <div
                class="skill-tooltip"
                v-if="skill.showTooltip"
                :class="getTooltipPosition(skill)"
              >
                <h3>{{ skill.name }}</h3>
                <p style="white-space: pre-wrap">
                  {{ skill.description || 'No description available' }}
                </p>
                <div class="resources-container" v-if="skill.resources?.length">
                  <div class="resources-container" v-if="skill.resources?.length">
                    <div
                      v-for="r in skill.resources"
                      :key="r.name"
                      class="resource-row"
                      :style="{color: r.color}"
                    >
                      {{ r.name }}{{ r.value ? ': ' + r.value : '' }}
                    </div>
                  </div>
                </div>
                <p class="damage" v-if="skill.damage">Damage: {{ skill.damage }}</p>
              </div>

              <!-- Action buttons -->
              <div v-if="skill.showActions" class="skill-actions">
                <button
                  class="action-btn"
                  @click.stop="editSkill(skill)"
                  @touchstart.stop.prevent="editSkill(skill)"
                  @mouseenter="showActionTooltip($event, 'Edit skill')"
                  @mouseleave="hideActionTooltip($event)"
                >
                  âœï¸
                </button>
                <button
                  class="action-btn"
                  @click.stop="deleteSkill(skill)"
                  @touchstart.stop.prevent="deleteSkill(skill)"
                  @mouseenter="showActionTooltip($event, 'Delete skill')"
                  @mouseleave="hideActionTooltip($event)"
                >
                  âŒ
                </button>
                <button
                  class="action-btn"
                  @click.stop="connectSkill(skill)"
                  @touchstart.stop.prevent="connectSkill(skill)"
                  @mouseenter="showActionTooltip($event, 'Connect to another skill. Left click on the destination.')"
                  @mouseleave="hideActionTooltip($event)"
                >
                  ðŸ”—
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div
        v-if="showLoadModal"
        class="load-modal-backdrop"
        :class="{ active: showLoadModal }"
        @click="showLoadModal = false"
      >
        <div class="load-modal" :class="{ active: showLoadModal }" @click.stop>
          <div class="options-section">
            <h3>Load Options</h3>
            <div class="option-group button-group">
              <button class="btn" @click="showLoadModal = false" style="color: white !important">
                Cancel
              </button>
              <button class="btn" @click="loadTree('merge')">Merge with Current</button>
              <button class="btn" @click="loadTree('overwrite')">Overwrite Tree</button>
            </div>
          </div>
        </div>
      </div>

      <div class="bottom-left-buttons">
        <!-- Add options button and panel -->
        <button
          class="options-button"
          @click="toggleOptions"
          @mouseenter="showActionTooltip($event, 'Options')"
          @mouseleave="hideActionTooltip($event)"
        >
          âš™ï¸
        </button>
        <button
          class="discord-button"
          @click="openDiscord"
          @mouseenter="showActionTooltip($event, 'Join the Discord, Feedback is Welcome!')"
          @mouseleave="hideActionTooltip($event)"
        >
          <img src="/img/discord-logo.png" alt="" style="width: 17px; height: 17px" />
        </button>
        <div class="options-panel" v-if="showOptions">
          <div class="options-section">
            <h3>Class Settings</h3>
            <div class="option-group">
              <label for="className">Class Name</label>
              <input
                type="text"
                id="className"
                v-model="currentName"
                placeholder="Enter class name..."
              />
            </div>
            <div class="option-group">
              <label>Max Points</label>
              <input
                type="number"
                v-model="maxPoints"
                min="1"
                @change="saveToHistory"
                placeholder="Maximum points allowed"
              />
            </div>
            <div class="option-group">
              <label>Skill Unlock</label>
              <select v-model="prerequisiteMode">
                <option value="none">No Previous Skills Required</option>
                <option value="one">At Least One Skill Required</option>
                <option default value="all">All Previous Skills Required</option>
              </select>
            </div>
          </div>

          <div class="options-section">
            <h3>Editor Settings</h3>
            <div class="option-group">
              <label>Mode</label>
              <select v-model="mode" @change="handleModeChange">
                <option value="edit">Edit Mode</option>
                <option value="view">View Mode</option>
              </select>
            </div>

            <div v-if="mode === 'edit'" class="option-group">
              <!-- <label>Grid Settings</label> -->
              <label>
                Use Grid
                <input type="checkbox" v-model="showGlobalGrid" />
              </label>
              <div class="grid-controls">
                <template v-if="showGlobalGrid">
                  <input type="range" v-model="gridOpacity" min="0" max="100" />
                  <span>Opacity: {{ gridOpacity }}%</span>
                  <input type="range" v-model="gridSize" min="20" max="300" />
                  <span>Size: {{ gridSize }}px</span>
                </template>
              </div>
            </div>

            <div v-if="!showGlobalGrid && mode === 'edit'" class="option-group">
              <div class="snap-controls">
                <label> Enable Snap </label>
                <input type="checkbox" v-model="gridSnapEnabled" @change="saveToHistory" />

                <!-- <label>Snap Threshold</label> -->
                <input
                  type="range"
                  v-model="snapThreshold"
                  min="1"
                  max="300"
                  placeholder="Snap threshold"
                />
                <span>Snap Threshold: {{ snapThreshold }}px</span>
              </div>
            </div>
          </div>

          <div class="options-section">
            <h3>Visual Settings</h3>

            <div class="option-group">
              <label>Background Color</label>
              <div class="color-controls">
                <input type="color" v-model="overlayColor" @input="updateBackground" />
                <input
                  type="range"
                  v-model="overlayOpacity"
                  min="0"
                  max="100"
                  @input="updateBackground"
                />
                <span>{{ overlayOpacity }}%</span>
              </div>
            </div>
            <div class="option-group">
              <label>Background Image</label>
              <div class="recent-backgrounds">
                <div
                  v-for="bg in recentBackgrounds"
                  :key="bg.id"
                  class="background-thumbnail"
                  :style="{ backgroundImage: `url(${bg.src})` }"
                  @click="currentBackgroundLink = bg.src; updateBackground()"
                ></div>
              </div>
              <div style="display: flex; gap: 10px; align-items: center">
                <input
                  type="file"
                  accept="image/*"
                  style="display: none"
                  ref="bgImageUpload"
                  @change="handleBackgroundUpload"
                />
                <button class="btn upload-button" @click="$refs.bgImageUpload.click()">
                  Upload Background
                </button>
              </div>
            </div>
            <div class="option-group">
              <label>Connection Width</label>
              <div class="range-container">
                <input
                  type="range"
                  v-model="config.connection.height"
                  min="0"
                  max="20"
                  step="0.5"
                />
                <span>{{ config.connection.height }}px</span>
              </div>
            </div>
            <div class="option-group">
              <label
                >Show Arrows
                <input type="checkbox" v-model="showArrows" />
              </label>
            </div>
            <div class="option-group">
              <label>Skill Shape</label>
              <select v-model="skillShape" @change="updateSkillShape">
                <option value="round">Round</option>
                <option value="square">Square</option>
                <option value="diamond">Diamond</option>
                <option value="hexagon">Hexagon</option>
              </select>
            </div>
          </div>

          <div class="options-section">
            <h3>Import/Download</h3>
            <div class="option-group button-group">
              <button class="btn" @click="importFromJson">ðŸ“‚ Load/Import JSON</button>
              <button class="btn" @click="exportToJson">ðŸ’¾ Save/Download JSON</button>
            </div>
          </div>
        </div>

        <div
          class="points-display"
          v-if="currentName"
          @mouseenter="showActionTooltip($event, 'Total Points Spent / Max Points')"
          @mouseleave="hideActionTooltip($event)"
        >
          {{ totalPointsSpent }} / {{ maxPoints }}
        </div>
        <button
          class="load-button"
          @click="importFromJson"
          @mouseenter="showActionTooltip($event, 'Load Skill Tree')"
          @mouseleave="hideActionTooltip($event)"
        >
          ðŸ“‚
        </button>
        <button
          class="download-button"
          @click="exportToJson"
          style="margin-left: 50px"
          @mouseenter="showActionTooltip($event, 'Save Skill Tree')"
          @mouseleave="hideActionTooltip($event)"
        >
          ðŸ’¾
        </button>
        <button
          class="share-button"
          @click="shareTree"
          @mouseenter="showActionTooltip($event, 'Share Tree')"
          @mouseleave="hideActionTooltip($event)"
        >
          ðŸ”—
        </button>
      </div>

      <!-- Edit Modal -->
      <div
        v-if="editingSkill"
        class="edit-modal-backdrop"
        :class="{ active: editingSkill }"
        @click="cancelEdit"
      >
        <div class="edit-modal" @click.stop>
          <div class="skill-preview-container">
            <div
              class="skill-preview"
              :class="{ 'skilled': editingSkill.currentPoints > 0 }"
              @click="openImageSelector"
              @touchstart.prevent="openImageSelector"
              style="cursor: pointer"
            >
              <img :src="editingSkill.image" :alt="editingSkill.name" />
              <div class="skill-points">
                {{ editingSkill.currentPoints }}/{{ editingSkill.maxPoints }}
              </div>
            </div>
            <div
              v-if="showImageSelector"
              class="image-selector-modal"
              :class="{ active: showImageSelector }"
            >
              <h2 style="color: #ffd100; margin-bottom: 20px">Select Skill Image</h2>
              <!-- Add this inside the image selector modal, just before the image grid -->
              <div class="image-upload-section">
                <label for="imageUpload" class="upload-button">
                  ðŸ“¤ Upload Custom Image
                  <input
                    type="file"
                    id="imageUpload"
                    accept="image/*"
                    style="display: none"
                    @change="handleImageUpload"
                  />
                </label>
                <div class="upload-info">
                  Supports PNG, JPG, GIF <br />
                  (Saved in your browser)
                </div>
              </div>
              <!-- Update the existing image grid -->
              <div class="image-grid">
                <img
                  v-for="image in allImages"
                  :key="image.id"
                  :src="image.src"
                  :class="['image-option', { selected: selectedImage === image.id }]"
                  @click="selectImage(image)"
                  :alt="image.name"
                />
              </div>
              <div class="image-selector-buttons">
                <button class="edit-modal-button cancel-button" @click="cancelImageSelection">
                  Cancel
                </button>
                <button class="edit-modal-button save-button" @click="saveImageSelection">
                  Save
                </button>
              </div>
            </div>
          </div>
          <div class="edit-form-container">
            <h2>Edit Skill</h2>
            <div class="edit-field">
              <label>Name</label>
              <input
                v-model="editingSkill.name"
                type="text"
                @keyup.enter="saveEdit"
                ref="nameInput"
              />
            </div>
            <div class="edit-field">
              <label>Description</label>
              <textarea
                v-model="editingSkill.description"
                placeholder="Enter skill description..."
                style="white-space: pre-wrap"
              ></textarea>
            </div>
            <div class="edit-field">
              <label>Resources/Stats</label>
              <div id="resources-container">
                <div
                  v-for="(resource, index) in editingSkill.resources"
                  :key="index"
                  class="edit-field row edit-resource-row"
                  draggable="true"
                  @dragstart="dragStart($event, index)"
                  @dragover.prevent
                  @drop="drop($event, index)"
                >
                  <input
                    v-model="resource.name"
                    type="text"
                    placeholder="Name"
                    :style="{color: resource.color}"
                  />
                  <input
                    v-model="resource.value"
                    type="text"
                    placeholder="Value"
                    :style="{color: resource.color}"
                  />
                  <input
                    v-model="resource.color"
                    type="text"
                    placeholder="Color"
                    :style="{color: resource.color}"
                  />
                  <button @click="editingSkill.resources.splice(index, 1)">Ã—</button>
                </div>
              </div>
              <button
                class="add-resource"
                @click="editingSkill.resources?.push({name:'',value:'',color:'#ffffff'})"
              >
                + Add Resource
              </button>
            </div>
            <div class="edit-field row">
              <div>
                <label
                  @mouseenter="showGenerateTooltip($event, 'Points spent in tree to unlock')"
                  @mouseleave="hideGenerateTooltip($event)"
                  >Required Points</label
                >
                <input
                  v-model="editingSkill.requiredPoints"
                  min="0"
                  type="number"
                  placeholder="0"
                />
              </div>
              <div>
                <label>Current Points</label>
                <input
                  v-model="editingSkill.currentPoints"
                  type="number"
                  min="0"
                  :max="editingSkill.maxPoints"
                  placeholder="Current"
                />
              </div>
              <div>
                <label>Max Points</label>
                <input
                  v-model="editingSkill.maxPoints"
                  type="number"
                  min="1"
                  max="20"
                  placeholder="Max"
                />
              </div>
            </div>

            <div class="edit-modal-buttons">
              <button class="edit-modal-button cancel-button" @click="cancelEdit">Cancel</button>
              <button class="edit-modal-button save-button" @click="saveEdit">Save</button>
            </div>
          </div>
        </div>
      </div>

      <div class="class-title" v-if="currentName">{{ currentName }}</div>

      <div class="history-controls">
        <button
          class="history-btn"
          @click="undo"
          :disabled="!canUndo"
          title="Undo"
          @mouseenter="showActionTooltip($event, 'Undo (Ctrl+Z)')"
          @mouseleave="hideActionTooltip($event)"
        >
          â†©ï¸
        </button>
        <button
          class="history-btn"
          @click="redo"
          :disabled="!canRedo"
          title="Redo"
          @mouseenter="showActionTooltip($event, 'Redo (Ctrl+Y)')"
          @mouseleave="hideActionTooltip($event)"
        >
          â†ªï¸
        </button>
      </div>
    </div>

    <script>
      const { createApp } = Vue;

      // Global configuration object
      const CONFIG = {
        paths: {
          assets: "/src/app/assets",
          config: "/src/app/config",
          images: {
            skills: "/img/skill",
            backgrounds: "/img/background",
            default: "/img/skill/axe-hammer-grey.png",
          },
        },
        grid: {
          spacing: 120,
          startX: 100,
          startY: 100,
        },
        skill: {
          size: 100, // diameter of skill circle
          offset: 30, // half of size, used for centering
        },
        connection: {
          height: 2, // Default connection height
        },
        skillImages: [
          "/axe-hammer-grey.png",
          "/fire-orb.png",
          "/fire-rock.png",
          "/flaming-spear.png",
          "/flaming-staff.png",
          "/golden-arrow.png",
          "/gray-spear.png",
          "/ornate-spear.png",
          "/skull-blue.png",
          "/small-trident.png",
          "/spectral-dagger.png",
          "/water-sword.png",
        ],
      };

      createApp({
        data() {
          return {
            config: CONFIG, // Make config available in template
            skills: [],
            connections: [],
            connectingFrom: null,
            skillIdCounter: 0,
            draggedSkill: null,
            dragOffset: { x: 0, y: 0 },
            draggedElement: null,
            isDragging: false,
            isLinking: false,
            hoveredSkill: null,
            defaultMaxPoints: 5, // Add this default value
            dragStartTime: null,
            dragStartPos: null,
            dragThreshold: 5, // pixels of movement to consider it a drag
            showOptions: false,
            isPanning: false,
            panStart: { x: 0, y: 0 },
            treePosition: { x: 0, y: 0 },
            scale: 1,
            minScale: 0.5,
            maxScale: 2,
            scaleStep: 0.1,
            isLoaded: false,
            touchStartX: null,
            touchStartY: null,
            lastTouchDistance: null,
            touchTimeout: null,
            doubleTapDelay: 300, // milliseconds
            lastTap: 0,
            editingSkill: null,
            oldSkills: null,
            oldBackgroundLink: null,
            oldName: null,
            currentBackgroundLink: null,
            currentName: null,
            currentClassDescription: null,
            inputText: "",
            isLoading: false,
            history: [],
            historyIndex: -1,
            maxHistorySize: 50,
            showImageSelector: false,
            selectedImage: null,
            availableImages: CONFIG.skillImages,
            skillShape: "round",
            customImages: [],
            gridSnapEnabled: true, // Add this new property
            snapThreshold: 8,
            mode: "edit",
            overlayColor: "#000000",
            overlayOpacity: 75,
            showArrows: true,
            showGlobalGrid: false,
            gridOpacity: 12,
            gridSize: window.innerWidth <= 768 ? 80 : 120, // Default grid size based on screen width
            maxPoints: 20, // Default max points
            selectionBox: null,
            selectedSkills: [],
            initialClick: { x: 0, y: 0 },
            showLoadModal: false,
            loadedData: null,
            recentBackgrounds: JSON.parse(localStorage.getItem("recentBackgrounds") || "[]"),
            initialPositions: null,
            prerequisiteMode: "all",
          };
        },

        computed: {
          canUndo() {
            return this.history.length >= 2 && this.historyIndex > 1;
          },
          canRedo() {
            return this.historyIndex < this.history.length - 1;
          },
          allImages() {
            // Convert default images to the same format as custom images
            const defaultImages = this.availableImages.map((image) => ({
              id: image,
              src: this.config.paths.images.skills + image,
              name: image,
              isDefault: true,
            }));

            // Combine with custom images
            return [...defaultImages, ...this.customImages];
          },
          gridStyle() {
            return {
              "--grid-opacity": this.gridOpacity / 100,
            };
          },

          gridLines() {
            if (!this.showGlobalGrid) return [];

            const lines = [];
            const treeEl = document.querySelector(".talent-tree");
            if (!treeEl) return lines;

            const bounds = treeEl.getBoundingClientRect();
            const extendedBounds = {
              width: bounds.width * 10,
              height: bounds.height * 10,
            };
            const size = parseInt(this.gridSize);

            // Calculate the offset based on tree position
            const offsetX = this.treePosition.x % size;
            const offsetY = this.treePosition.y % size;

            // Calculate number of lines needed
            const numHorizontal = Math.ceil(extendedBounds.height / size);
            const numVertical = Math.ceil(extendedBounds.width / size);

            // Add horizontal lines
            for (let i = 0; i <= numHorizontal; i++) {
              lines.push({
                id: `h${i}`,
                type: "horizontal",
                style: {
                  top: `${i * size + offsetY}px`,
                },
              });
            }

            // Add vertical lines
            for (let i = 0; i <= numVertical; i++) {
              lines.push({
                id: `v${i}`,
                type: "vertical",
                style: {
                  left: `${i * size + offsetX}px`,
                },
              });
            }

            return lines;
          },
          totalPointsSpent() {
            return this.skills.reduce((total, skill) => total + skill.currentPoints, 0);
          },
        },
        mounted() {
          // Check if we're loading a specific tree
          const match = window.location.pathname.match(/\/tree\/([^\/]+)/);
          if (match) {
            const treeId = match[1];
            this.loadTreeById(treeId);
          } else {
            this.loadDefaultConfig();
          }

          // Add keyboard event listener
          document.addEventListener("keydown", this.handleKeyboardShortcuts);

          setTimeout(() => {
            document.querySelector(".talent-tree").classList.add("loaded");
            this.saveToHistory(); // Save initial state
          }, 1000);

          // Load custom images from localStorage
          this.loadCustomImages();

          this.mode = new URLSearchParams(window.location.search).get("mode") || "edit";
          document.body.classList.toggle("view-mode", this.mode === "view");

          if (this.mode === "view") {
            this.showGlobalGrid = false;
          } else {
            this.showGlobalGrid = true;
          }

          // Set zoom tree dimensions to exact pixel values
          const zoomTree = document.querySelector(".zoom-tree");
          if (zoomTree) {
            zoomTree.style.width = `${window.innerWidth * 2}px`;
            zoomTree.style.height = `${window.innerHeight * 2}px`;
          }

          window.addEventListener("resize", this.handleResize);
        },
        beforeUnmount() {
          // Clean up event listener
          document.removeEventListener("keydown", this.handleKeyboardShortcuts);
          window.removeEventListener("resize", this.handleResize);
        },
        methods: {
          handleKeyboardShortcuts(event) {
            // Check if ctrl/cmd key is pressed
            if (event.ctrlKey || event.metaKey) {
              if (event.key === "z") {
                event.preventDefault();
                // Only allow undo when there are at least 2 states in history
                if (this.history.length >= 2 && this.historyIndex > 0) {
                  this.undo();
                }
              } else if (event.key === "y") {
                event.preventDefault();
                if (this.canRedo) {
                  this.redo();
                }
              } else if (event.key === "c") {
                this.copy();
              } else if (event.key === "v") {
                this.paste();
              }
            } else if (event.key === "Delete") {
              // Get all selected skills
              const selectedSkills = this.skills.filter((skill) =>
                this.selectedSkills.includes(skill.id)
              );

              // Delete each selected skill using existing deleteSkill method
              selectedSkills.forEach((skill) => {
                this.deleteSkill(skill);
              });

              // Clear selection
              this.deselectAllSkills();

              // Save state to history
              this.saveToHistory();
            }
          },
          loadDefaultConfig() {
            fetch(`${this.config.paths.config}/default.json`)
              .then((response) => response.json())
              .then((data) => {
                this.skills = [];
                this.connections = [];

                // Set the initial class name and background
                const isMobile = window.innerWidth <= 768;

                // Set the initial class name and background
                this.currentName = isMobile
                  ? "Try Tapping A Skill"
                  : "Try Generating a Class, or Clicking a Skill.";

                this.currentBackgroundLink = data["Class Image"]
                  ? `${this.config.paths.images.backgrounds}${data["Class Image"]}`
                  : "/img/background/grass-ancient.jpg";

                // First pass: Create a map of skill dependencies and levels
                const skillLevels = new Map();
                const skillDeps = new Map();

                data.Skills.forEach((skill) => {
                  const name = skill["Skill Name"];
                  skillDeps.set(
                    name,
                    skill["Skill Prerequisite"] !== "-"
                      ? skill["Skill Prerequisite"].split(" (")[0]
                      : null
                  );
                });

                // Calculate levels based on prerequisites
                const calculateLevel = (skillName, visited = new Set()) => {
                  if (visited.has(skillName)) return 0; // Handle circular dependencies
                  visited.add(skillName);

                  const prereq = skillDeps.get(skillName);
                  if (!prereq) return 0;

                  return 1 + calculateLevel(prereq, visited);
                };

                // Assign levels to all skills
                data.Skills.forEach((skill) => {
                  const level = calculateLevel(skill["Skill Name"]);
                  skillLevels.set(skill["Skill Name"], level);
                });

                // Group skills by level
                const skillsByLevel = new Map();
                skillLevels.forEach((level, name) => {
                  if (!skillsByLevel.has(level)) {
                    skillsByLevel.set(level, []);
                  }
                  skillsByLevel.get(level).push(name);
                });

                // Calculate positions
                data.Skills = data.Skills.map((skill) => {
                  if (!skill["Skill Position"]) {
                    const level = skillLevels.get(skill["Skill Name"]);
                    const skillsAtLevel = skillsByLevel.get(level);
                    const indexAtLevel = skillsAtLevel.indexOf(skill["Skill Name"]);

                    // Calculate grid position
                    // Level determines x (column), index within level determines y (row)
                    const x = level + 1; // Add 1 to avoid x=0
                    const y = indexAtLevel + 1;

                    skill["Skill Position"] = `(${x},${y})`;
                  }
                  return skill;
                });

                // Continue with existing positioning logic...
                const viewport = {
                  width: window.innerWidth,
                  height: window.innerHeight,
                };

                // Find bounds of the skill tree
                let minX = Infinity,
                  minY = Infinity,
                  maxX = -Infinity,
                  maxY = -Infinity;

                // First pass: calculate bounds
                data.Skills.forEach((skillData) => {
                  const posMatch = skillData["Skill Position"].match(/\((\d+),\s*(\d+)\)/);
                  const x = parseInt(posMatch[1]);
                  const y = parseInt(posMatch[2]);

                  const gridX = this.config.grid.startX + (x - 1) * this.config.grid.spacing;
                  const gridY = this.config.grid.startY + (y - 1) * this.config.grid.spacing;

                  minX = Math.min(minX, gridX);
                  minY = Math.min(minY, gridY);
                  maxX = Math.max(maxX, gridX);
                  maxY = Math.max(maxY, gridY);
                });

                // Calculate center offset
                const treeWidth = maxX - minX;
                const treeHeight = maxY - minY;
                const offsetX = viewport.width - treeWidth - treeWidth / 2;
                const offsetY = viewport.height - treeHeight - treeHeight / 2 + 250;

                // Second pass: create skills with centered positions
                data.Skills.forEach((skillData, index) => {
                  const posMatch = skillData["Skill Position"].match(/\((\d+),\s*(\d+)\)/);
                  const x = parseInt(posMatch[1]);
                  const y = parseInt(posMatch[2]);

                  const initialX =
                    this.config.grid.startX + (x - 1) * this.config.grid.spacing + offsetX;
                  const initialY =
                    this.config.grid.startY + (y - 1) * this.config.grid.spacing + offsetY;

                  // Snap to grid
                  // Use the same snapToGrid method as drag operations
                  const snappedPos = this.snapToGrid(initialX, initialY);

                  const skill = {
                    id: ++this.skillIdCounter,
                    name: skillData["Skill Name"],
                    x: snappedPos.x,
                    y: snappedPos.y,
                    showActions: false,
                    level: skillData["Skill Level"],
                    // damage: skillData["Skill Damage"],
                    description: skillData["Skill Description"],
                    maxPoints: skillData["Skill Max Points"] || this.defaultMaxPoints,
                    currentPoints: index < 4 ? 1 : skillData["Skill Current Points"] || 0,
                    image: `${this.config.paths.images.skills}${skillData["Skill Image"]}`,
                    shouldAnimate: false,
                    resources: [],
                  };
                  // Add damage to resources if it exists
                  if (skillData["Skill Damage"]) {
                    skill.resources.push({
                      name: "Damage",
                      value: skillData["Skill Damage"],
                      color: "#ff4747",
                    });
                  }

                  this.skills.push(skill);

                  // Create connection if there's a prerequisite
                  if (skillData["Skill Prerequisite"] !== "-") {
                    const prereqName = skillData["Skill Prerequisite"].split(" (")[0];
                    const prereqSkill = this.skills.find((s) => s.name === prereqName);
                    if (prereqSkill) {
                      this.connections.push({
                        id: `${prereqSkill.id}-${skill.id}`,
                        from: prereqSkill.id,
                        to: skill.id,
                      });
                    }
                  }
                });

                // Trigger animations with a slight delay for each skill
                setTimeout(() => {
                  this.skills.forEach((skill, index) => {
                    setTimeout(() => {
                      skill.shouldAnimate = true;
                    }, index * 50); // 50ms delay between each skill
                  });
                }, 100); // Initial delay of 100ms

                // Initialize history with the initial state
                this.history = [];
                this.historyIndex = -1; // Reset history index

                // Force an initial state save after everything is loaded
                this.$nextTick(() => {
                  if (this.skills.length > 0) {
                    this.saveToHistory();
                  }
                });
              })
              .catch((error) => console.error("Error loading default config:", error));
          },
          getAdjustedCoordinates(oldX, oldY, scale) {
            // Calculate the offset factor using the quadratic function:
            // f(s) = -0.5 * s^2 + 1.75 * s - 0.75
            // const offsetFactor = -0.5 * scale * scale + 1.75 * scale - 0.75;

            // // Adjust x and y using the corresponding window dimensions
            // const x = oldX / scale + window.innerWidth * offsetFactor;
            // const y = oldY / scale + window.innerHeight * offsetFactor;

            const x = oldX / scale + (window.innerWidth / 2) * (2 - 1 / scale);
            const y = oldY / scale + (window.innerHeight / 2) * (2 - 1 / scale);

            return { x, y };
          },
          handleClick(event) {
            if (this.isViewMode()) return;
            // Don't create skill if we just finished making a selection
            // if (!this.selectionBox) {
            // if (!event.target.classList.contains('skill')) {
            // this.selectedSkills = []; // Clear selection when clicking empty space
            // }
            // return;
            // }

            //base equation event.offsetX / this.scale + ( window.innerWidth) / 2
            //scale 0.5 : event.offsetX * 2
            //sclae 1 :  + window.innerWidth/2
            //scale 2 : event.offsetX / this.scale + (1.5 * window.innerWidth) / 2
            // x * 2 = 1.5
            const adjustedCoordinates = this.getAdjustedCoordinates(
              event.offsetX,
              event.offsetY,
              this.scale
            );

            if (!this.isDragging && event.target.classList.contains("talent-tree")) {
              if (!this.isDragging && this.selectionBox === null) {
                this.createSkill(
                  adjustedCoordinates.x, // + window.innerWidth / 2,
                  adjustedCoordinates.y // + window.innerHeight / 2
                );
              }
            }
            this.isDragging = false;
          },

          createSkill(x, y) {
            this.deselectAllSkills();

            const skill = {
              id: ++this.skillIdCounter,
              x: x - this.config.skill.offset,
              y: y - this.config.skill.offset,
              name: `Skill ${this.skillIdCounter}`,
              showActions: false,
              showTooltip: false,
              description: "Click to edit skill description.",
              // damage: '0',
              maxPoints: this.defaultMaxPoints,
              currentPoints: 0,
              requiredPoints: 0,
              image: this.config.paths.images.default,
              shouldAnimate: true, // Set to true immediately
              resources: [],
            };
            if (this.showGlobalGrid) {
              const snappedPos = this.snapToGrid(x, y);
              skill.x = snappedPos.x;
              skill.y = snappedPos.y;
            }
            this.skills.push(skill);
            this.saveToHistory();

            // Force the image to be visible immediately after creation
            this.$nextTick(() => {
              const skillElement = document.querySelector(`[data-skill-id="${skill.id}"] img`);
              if (skillElement) {
                skillElement.style.opacity = "1";
              }
            });
          },

          toggleActions(skill) {
            // Only process click if we haven't dragged
            if (!this.isDragging) {
              if (this.isLinking) {
                // If we're in linking mode, treat this as the second skill
                this.connectSkill(skill);
                return;
              }

              // Deselect all skills only if this skill is not already selected
              if (!this.selectedSkills.includes(skill)) {
                this.deselectAllSkills();
              }

              // Hide all other action menus
              // this.skills.forEach((s) => {
              //   if (s.id !== skill.id) s.showActions = false;
              // });

              // Increment points only on clean click
              if (skill.currentPoints < skill.maxPoints) {
                if (this.isViewMode()) {
                  if (this.canAddPoint(skill)) {
                    skill.currentPoints++;
                  }
                } else {
                  if (skill.showActions) {
                    //Avoid increment if first click to edit skil
                    if (this.canAddPoint(skill)) {
                      skill.currentPoints++;
                    }
                  } else {
                    skill.showActions = true;
                    this.selectedSkills.push(skill);
                  }
                  console.log("selectedSkills", this.selectedSkills.length);
                }
              }

              if (this.isViewMode()) return;

              // Don't toggle if actions are already shown
              // if (!skill.showActions) {
              //   skill.showActions = true;
              // }
            }
          },

          editSkill(skill) {
            // Ensure resources is initialized when editing
            this.editingSkill = {
              ...skill,
              resources: skill.resources || [],
            };
            // Focus name input after modal opens
            this.$nextTick(() => {
              this.$refs.nameInput?.focus();
            });
          },

          saveEdit() {
            if (!this.editingSkill) return;

            const skill = this.skills.find((s) => s.id === this.editingSkill.id);
            if (skill) {
              skill.name = this.editingSkill.name;
              skill.description = this.editingSkill.description;
              skill.damage = this.editingSkill.damage;
              skill.image = this.editingSkill.image;

              // Handle max points and current points changes
              const newMaxPoints = parseInt(this.editingSkill.maxPoints);
              const newCurrentPoints = parseInt(this.editingSkill.currentPoints);
              const newRequiredPoints = parseInt(this.editingSkill.requiredPoints);
              skill.maxPoints = newMaxPoints;
              skill.currentPoints = Math.min(newCurrentPoints, newMaxPoints); // Update current points
              skill.requiredPoints = newRequiredPoints;
              skill.resources = this.editingSkill.resources || [];
            }
            this.editingSkill = null;
            this.showImageSelector = false;
            this.saveToHistory();
          },

          cancelEdit() {
            this.editingSkill = null;
          },

          deleteSkill(skill) {
            this.skills = this.skills.filter((s) => s.id !== skill.id);
            this.connections = this.connections.filter(
              (c) => c.from !== skill.id && c.to !== skill.id
            );
            this.saveToHistory();
          },

          connectSkill(skill) {
            if (!this.connectingFrom) {
              // Starting a new connection
              this.connectingFrom = skill;
              this.isLinking = true;
              // Hide actions menu and all tooltips
              this.skills.forEach((s) => {
                s.showActions = false;
                s.showTooltip = false;
              });
            } else {
              // Completing a connection
              if (this.connectingFrom.id !== skill.id) {
                this.connections.push({
                  id: `${this.connectingFrom.id}-${skill.id}`,
                  from: this.connectingFrom.id,
                  to: skill.id,
                });
              }
              // Reset connection state
              this.connectingFrom = null;
              this.isLinking = false;
            }
            this.saveToHistory();
          },

          getConnectionStyle(connection) {
            const fromSkill = this.skills.find((s) => s.id === connection.from);
            const toSkill = this.skills.find((s) => s.id === connection.to);

            if (!fromSkill || !toSkill) return {};

            const dx = toSkill.x - fromSkill.x;
            const dy = toSkill.y - fromSkill.y;
            const angle = (Math.atan2(dy, dx) * 180) / Math.PI;
            const length = Math.sqrt(dx * dx + dy * dy);

            return {
              left: fromSkill.x + 30 + "px",
              top: fromSkill.y + 30 + "px",
              width: length + "px",
              height: this.config.connection.height + "px", // Use configurable height
              transform: `rotate(${angle}deg)`,
            };
          },

          startDrag(event, skill) {
            if (this.isViewMode()) return;

            event.preventDefault();
            let pointerOld = event.touches ? event.touches[0] : event;
            console.log("pointer before", pointerOld.clientX, pointerOld.clientY);
            const adjustedCoordinates = this.getAdjustedCoordinates(
              pointerOld.clientX,
              pointerOld.clientY,
              this.scale
            );
            let pointer = {
              clientX: adjustedCoordinates.x,
              clientY: adjustedCoordinates.y,
            };
            console.log("pointer", adjustedCoordinates.x, pointer.clientY);
            // Store initial positions of selected skills
            this.initialPositions = {};
            // this.selectedSkills.forEach((skill) => {
            //   if (skill) {
            //     this.initialPositions[skill.id] = { x: skill.x, y: skill.y };
            //   }
            // });
            this.selectedSkills.forEach((selectedSkill) => {
              if (selectedSkill) {
                this.initialPositions[selectedSkill.id] = {
                  x: selectedSkill.x - skill.x, // Store relative offset from dragged skill
                  y: selectedSkill.y - skill.y,
                };
              }
            });

            // Store initial position and time
            this.dragStartTime = Date.now();
            this.dragStartPos = {
              x: pointer.clientX,
              y: pointer.clientY,
            };

            this.isDragging = false; // Reset drag state
            this.draggedSkill = skill;
            const treeRect = event.target.closest(".talent-tree").getBoundingClientRect();

            this.draggedElement = event.target.closest(".skill");

            this.dragOffset = {
              x: pointer.clientX - (skill.x + treeRect.left),
              y: pointer.clientY - (skill.y + treeRect.top),
            };

            // Add event listeners
            if (event.touches) {
              document.addEventListener("touchmove", this.handleDrag, { passive: false });
              document.addEventListener("touchend", this.stopDrag);
            } else {
              document.addEventListener("mousemove", this.handleDrag);
              document.addEventListener("mouseup", this.stopDrag);
            }
          },

          handleDrag(event) {
            if (!this.draggedSkill) return;

            let pointerOld = event.touches ? event.touches[0] : event;
            const adjustedCoordinates = this.getAdjustedCoordinates(
              pointerOld.clientX,
              pointerOld.clientY,
              this.scale
            );
            let pointer = {
              clientX: adjustedCoordinates.x,
              clientY: adjustedCoordinates.y,
              pageX: adjustedCoordinates.x,
              pageY: adjustedCoordinates.y,
            };
            // pointer.pageX = 500;
            // pointer.pageY = adjustedCoordinates.y;
            // Move selected skills
            // if (this.draggedSkill) {
            //     const dx = event.clientX - this.dragOffset.x - this.draggedSkill.x;
            //     const dy = event.clientY - this.dragOffset.y - this.draggedSkill.y;

            //     const skillsToMove = [...new Set([...this.selectedSkills, this.draggedSkill])];
            //     skillsToMove.forEach(skill => {
            //         skill.x += dx;
            //         skill.y += dy;
            //     });
            // }

            // Check if movement exceeds drag threshold
            if (!this.isDragging) {
              const dx = pointer.pageX - this.dragStartPos.x;
              const dy = pointer.pageY - this.dragStartPos.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance > this.dragThreshold) {
                this.isDragging = true;
              }
            }

            if (this.isDragging) {
              const treeRect = document.querySelector(".talent-tree").getBoundingClientRect();
              const newX = pointer.pageX - this.dragOffset.x - treeRect.left - window.scrollX;
              const newY = pointer.pageY - this.dragOffset.y - treeRect.top - window.scrollY;

              let finalX = newX;
              let finalY = newY;

              if (this.gridSnapEnabled) {
                // Find nearby skills for snapping
                const snapThreshold = this.snapThreshold;
                const nearbySkills = this.skills.filter(
                  (skill) =>
                    skill.id !== this.draggedSkill.id &&
                    (Math.abs(skill.x - newX) < 150 || Math.abs(skill.y - newY) < 150) // Consider skills nearby in either direction
                );

                // Find the closest skill in x-direction within threshold
                const closestXSkill = nearbySkills.reduce((closest, skill) => {
                  const distance = Math.abs(skill.x - newX);
                  if (
                    distance < snapThreshold &&
                    (!closest || distance < Math.abs(closest.x - newX))
                  ) {
                    return skill;
                  }
                  return closest;
                }, null);

                // Find the closest skill in y-direction within threshold
                const closestYSkill = nearbySkills.reduce((closest, skill) => {
                  const distance = Math.abs(skill.y - newY);
                  if (
                    distance < snapThreshold &&
                    (!closest || distance < Math.abs(closest.y - newY))
                  ) {
                    return skill;
                  }
                  return closest;
                }, null);

                if (closestXSkill) {
                  finalX = closestXSkill.x;
                }

                if (closestYSkill) {
                  finalY = closestYSkill.y;
                }
              }

              // Apply grid snapping if enabled
              if (this.showGlobalGrid) {
                const snappedPos = this.snapToGrid(newX, newY);

                finalX = snappedPos.x;
                finalY = snappedPos.y;
              }

              // Calculate movement delta
              const dx = finalX - this.dragStartPos.x;
              const dy = finalY - this.dragStartPos.y;

              if (!this.draggedElement || !this.draggedSkill) return; // Early return if elements are missing
              requestAnimationFrame(() => {
                this.draggedElement.style.left = `${finalX}px`;
                this.draggedElement.style.top = `${finalY}px`;

                this.draggedSkill.x = finalX;
                this.draggedSkill.y = finalY;

                // console.log("selectedSkills", this.selectedSkills)
                // Move all other selected skills maintaining relative positions
                // this.selectedSkills.forEach((skillInArray) => {
                //   if (skillInArray.id !== this.draggedSkill.id) {
                //     let skill = this.skills.find((s) => s.id === skillInArray.id);
                //     if (skill) {
                //       skill.x =
                //         finalX -
                //         this.dragStartPos.x +
                //         30 +
                //         this.initialPositions[skillInArray.id].x;
                //       skill.y =
                //         finalY -
                //         this.dragStartPos.y +
                //         30 +
                //         this.initialPositions[skillInArray.id].y;
                //       const skillElement = document.querySelector(`[data-skill-id="${skill.id}"]`);
                //       if (skillElement) {
                //         skillElement.style.left = `${skill.x}px`;
                //         skillElement.style.top = `${skill.y}px`;
                //       }
                //     }
                //   }
                // });
                this.selectedSkills.forEach((skillInArray) => {
                  if (skillInArray.id !== this.draggedSkill.id) {
                    let skill = this.skills.find((s) => s.id === skillInArray.id);
                    if (skill) {
                      const relativePos = this.initialPositions[skillInArray.id];
                      skill.x = finalX + relativePos.x; // Use relative position directly
                      skill.y = finalY + relativePos.y;

                      const skillElement = document.querySelector(`[data-skill-id="${skill.id}"]`);
                      if (skillElement) {
                        skillElement.style.left = `${skill.x}px`;
                        skillElement.style.top = `${skill.y}px`;
                      }
                    }
                  }
                });
              });
            }
          },

          stopDrag() {
            this.selectionBox = null;
            // Don't reset isDragging immediately
            const wasDragging = this.isDragging;

            this.draggedSkill = null;
            this.initialPositions = null; // Clean up the initial positions

            // Use setTimeout to reset isDragging after click events have processed
            setTimeout(() => {
              this.isDragging = false;
            }, 0);

            // Remove event listeners
            document.removeEventListener("mousemove", this.handleDrag);
            document.removeEventListener("mouseup", this.stopDrag);
            document.removeEventListener("touchmove", this.handleDrag);
            document.removeEventListener("touchend", this.stopDrag);
          },

          showActionTooltip(event, text) {
            const tooltip = document.createElement("div");
            tooltip.className = "action-btn-tooltip";
            if (text === "Edit skill" && this.selectedSkills.length > 1) {
              text = "Edit skills";
            }
            tooltip.textContent = text;
            event.target.appendChild(tooltip);
          },

          hideActionTooltip(event) {
            const tooltip = event.target.querySelector(".action-btn-tooltip");
            if (tooltip) {
              tooltip.remove();
            }
          },

          decrementPoints(skill) {
            if (skill.currentPoints > 0) {
              skill.currentPoints--;
            }
          },

          isConnectionActive(connection) {
            const fromSkill = this.skills.find((s) => s.id === connection.from);
            const toSkill = this.skills.find((s) => s.id === connection.to);
            return fromSkill?.currentPoints > 0 && toSkill?.currentPoints > 0;
          },

          toggleOptions() {
            this.showOptions = !this.showOptions;
          },
          handleImageLoad(event) {
            event.target.style.opacity = "1";
          },

          startPan(event) {
            if (event.button === 0 && event.target.classList.contains("talent-tree")) {
              // Left click for selection box
              event.preventDefault();
              let adjustedCoordinates = this.getAdjustedCoordinates(
                event.offsetX,
                event.offsetY,
                this.scale
              );
              this.initialClick = {
                x: adjustedCoordinates.x,
                y: adjustedCoordinates.y,
              };
              document.addEventListener("mousemove", this.handleSelection);
              document.addEventListener("mouseup", this.stopSelection);
            }
            if (event.button === 2) {
              // Right click
              event.preventDefault();
              this.isPanning = true;
              this.panStart = {
                x: event.clientX - this.treePosition.x,
                y: event.clientY - this.treePosition.y,
              };
              document.addEventListener("mousemove", this.handlePan);
              document.addEventListener("mouseup", this.stopPan);
            }
          },

          handlePan(event) {
            if (this.isPanning) {
              const newX = event.clientX - this.panStart.x;
              const newY = event.clientY - this.panStart.y;
              this.treePosition = { x: newX, y: newY };

              // Update all skill positions
              this.skills.forEach((skill) => {
                skill.x += event.movementX;
                skill.y += event.movementY;
              });

              // Force grid recomputation by triggering reactivity
              if (this.showGlobalGrid) {
                this.$forceUpdate();
              }
            }
          },

          stopPan() {
            this.isPanning = false;
            document.removeEventListener("mousemove", this.handlePan);
            document.removeEventListener("mouseup", this.stopPan);
          },

          handleZoom(event) {
            event.preventDefault();

            // Determine zoom direction
            const zoomIn = event.deltaY < 0;

            // Calculate new scale
            let newScale = this.scale + (zoomIn ? this.scaleStep : -this.scaleStep);

            // Clamp scale between min and max values
            newScale = Math.max(this.minScale, Math.min(this.maxScale, newScale));

            // // Only proceed if scale actually changed
            // if (newScale !== this.scale) {
            //   // Get mouse position relative to the tree
            //   const rect = event.target.getBoundingClientRect();
            //   const mouseX = event.clientX - rect.left;
            //   const mouseY = event.clientY - rect.top;

            //   // Calculate scale factor
            //   const scaleFactor = newScale / this.scale;

            //   // Update all skill positions relative to mouse position
            //   this.skills.forEach((skill) => {
            //     skill.x = mouseX + (skill.x - mouseX) * scaleFactor;
            //     skill.y = mouseY + (skill.y - mouseY) * scaleFactor;
            //   });

            //   const skillElements = document.querySelectorAll(".skill");
            //   skillElements.forEach((element) => {
            //     // element.style.transform = `scale(${newScale})`;
            //     // Adjust the hit area for interactions
            //     // element.style.width = `${60 - 10 / newScale}px`;
            //     // element.style.height = `${60 - 10 / newScale}px`;
            //   });

            const container = document.querySelector(".zoom-tree");
            if (container) {
              container.style.transform = `translate(-25%, -25%) scale(${newScale})`;
              // container.style.transformOrigin = "center center";
            }
            // const skills = document.querySelector(".skill-connections-container");
            // if (skills) {
            //   skills.style.transform = `scale(${newScale})`;
            //   skills.style.transformOrigin = "center center";
            // }
            if (this.showGlobalGrid) {
              // Update the tree position slightly to force reactivity
              this.treePosition = {
                x: this.treePosition.x,
                y: this.treePosition.y,
              };

              // Force Vue to recompute the grid lines
              this.$nextTick(() => {
                this.$forceUpdate();
              });
              // }

              this.scale = newScale;
            }
          },

          exportToJson() {
            const exportData = {
              Skills: this.skills.map((skill) => {
                // Find all connections where this skill is the prerequisite
                const dependentSkills = this.connections
                  .filter((conn) => conn.from === skill.id)
                  .map((conn) => {
                    const targetSkill = this.skills.find((s) => s.id === conn.to);
                    return targetSkill ? targetSkill.name : null;
                  })
                  .filter((name) => name !== null);

                return {
                  "Skill Name": skill.name,
                  "Skill Position": `(${Math.round(
                    (skill.x - this.config.grid.startX) / this.config.grid.spacing + 1
                  )},${Math.round(
                    (skill.y - this.config.grid.startY) / this.config.grid.spacing + 1
                  )})`,
                  "Skill Position Exact": { x: skill.x, y: skill.y },
                  "Skill Level": skill.level || 1,
                  "Skill Damage": skill.damage,
                  "Skill Description": skill.description,
                  "Skill Max Points": skill.maxPoints,
                  "Skill Current Points": skill.currentPoints,
                  "Skill Image": skill.image.startsWith("data:")
                    ? this.customImages.find((img) => img.src === skill.image)?.id || skill.image
                    : skill.image.split("/img/skill")[1],
                  "Skill Dependencies": dependentSkills, // Add this new field
                  "Skill Prerequisite": this.getPrerequisite(skill),
                  "Skill Resources": skill.resources || [],
                };
              }),
              "Class Name": this.currentName,
              FullData: this.$data,
              // "FullData": {
              //     ...this.$data,
              //     recentBackgrounds: [], // Clear recent backgrounds from full data
              // }
            };

            // Create and trigger download
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataUri = "data:application/json;charset=utf-8," + encodeURIComponent(dataStr);
            const exportFileDefaultName = "talent-tree-config.json";

            const linkElement = document.createElement("a");
            linkElement.setAttribute("href", dataUri);
            linkElement.setAttribute("download", exportFileDefaultName);
            linkElement.click();
          },

          getPrerequisite(skill) {
            const connection = this.connections.find((c) => c.to === skill.id);
            if (!connection) return "-";

            const prereqSkill = this.skills.find((s) => s.id === connection.from);
            return prereqSkill ? `${prereqSkill.name} (${prereqSkill.level || 1})` : "-";
          },

          handleSkillTouch(event, skill) {
            event.preventDefault();

            // Only proceed with skill touch handling if we're not panning
            if (!this.isPanning) {
              if (this.isLinking) {
                this.connectSkill(skill);
                return;
              }

              this.skills.forEach((s) => {
                const el = document.querySelector(`[data-skill-id="${s.id}"]`);
                if (el) {
                  el.style.zIndex = s.id === skill.id ? "1000" : "10";
                }
              });

              const currentTime = new Date().getTime();
              const tapLength = currentTime - this.lastTap;

              // Hide all other tooltips before showing the current one
              this.skills.forEach((s) => {
                if (s.id !== skill.id) {
                  s.showTooltip = false;
                }
              });

              // Show tooltip for current skill
              skill.showTooltip = true;

              // Store touch start position for drag detection
              const touch = event.touches[0];
              this.touchStartX = touch.clientX;
              this.touchStartY = touch.clientY;

              // Start potential drag operation
              this.startDrag(event, skill);

              // Set a timeout to detect if this is a tap or a drag
              this.touchTimeout = setTimeout(() => {
                if (!this.isDragging) {
                  // This was a tap, not a drag
                  if (tapLength < this.doubleTapDelay && tapLength > 0) {
                    // Double tap - decrement points (like right click)
                    if (skill.currentPoints > 0) {
                      skill.currentPoints--;
                    }
                  } else {
                    // Single tap - toggle actions and increment points
                    if (skill.currentPoints < skill.maxPoints) {
                      skill.currentPoints++;
                    }

                    if (this.isViewMode()) return;

                    this.skills.forEach((s) => {
                      if (s.id !== skill.id) s.showActions = false;
                    });

                    if (!skill.showActions) {
                      skill.showActions = true;
                    }
                  }
                }
              }, 200);

              this.lastTap = currentTime;
            }
          },

          handleSkillTouchEnd(skill) {},

          handleTouchMove(event) {
            if (this.touchTimeout) {
              clearTimeout(this.touchTimeout);
            }

            if (event.touches.length === 1) {
              const touch = event.touches[0];
              const deltaX = touch.clientX - this.touchStartX;
              const deltaY = touch.clientY - this.touchStartY;

              // If we're dragging a skill
              if (this.draggedSkill) {
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                  this.isDragging = true;
                  this.handleDrag(event);
                }
              } else {
                // If we're panning the tree
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                  this.skills.forEach((skill) => {
                    skill.x += deltaX;
                    skill.y += deltaY;
                  });
                  this.touchStartX = touch.clientX;
                  this.touchStartY = touch.clientY;
                }
              }
            } else if (event.touches.length === 2) {
              // Handle pinch zoom
              const touch1 = event.touches[0];
              const touch2 = event.touches[1];
              const currentDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
              );

              if (this.lastTouchDistance) {
                const delta = currentDistance - this.lastTouchDistance;
                const zoomEvent = new WheelEvent("wheel", {
                  deltaY: -delta,
                });
                this.handleZoom(zoomEvent);
              }
              this.lastTouchDistance = currentDistance;
            }
          },

          handleTouchEnd(event) {
            if (this.touchTimeout) {
              clearTimeout(this.touchTimeout);
            }

            if (this.draggedSkill) {
              this.stopDrag();
            }

            this.touchStartX = null;
            this.touchStartY = null;
            this.lastTouchDistance = null;

            // Reset dragging state after a short delay to allow click events to process
            setTimeout(() => {
              this.isDragging = false;
            }, 0);
          },

          generateRandomTree() {
            if (this.skills) {
              this.oldSkills = this.skills;
              this.oldBackgroundLink = this.currentBackgroundLink;
              this.oldName = this.currentName;
            }

            const talentTree = document.querySelector(".talent-tree");
            if (talentTree) {
              talentTree.style.filter = "blur(100px)";
            }

            fetch("/random_tree")
              .then((response) => response.json())
              .then((data) => {
                this.treePosition = { x: 0, y: 0 };
                this.scale = 1;

                const img = new Image();
                img.onload = () => {
                  if (talentTree) {
                    setTimeout(() => {
                      talentTree.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.85)), url('${CONFIG.paths.images.backgrounds}${data["Class Image"]}')`;
                      talentTree.style.filter = "blur(0)";
                    }, 100);
                  }
                };
                img.src = CONFIG.paths.images.backgrounds + data["Class Image"];

                this.loadSkillsFromData(data["Skills"]);
                this.currentBackgroundLink = CONFIG.paths.images.backgrounds + data["Class Image"];
                this.currentName = data["Class Name"];
                this.currentClassDescription = data["Class Description"];

                // Save to history after loading
                setTimeout(() => {
                  this.saveToHistory();
                }, 1000);
              })
              .catch((error) => {
                console.error("Error fetching random skill tree:", error);
                if (talentTree) {
                  talentTree.style.opacity = "1";
                  talentTree.style.filter = "blur(0)";
                }
              });
          },

          loadSkillsFromData(skillsData) {
            this.skills = [];
            this.connections = [];
            this.skillIdCounter = 0;

            // First pass: Create a map of skill dependencies and levels
            const skillLevels = new Map();
            const skillDeps = new Map();

            skillsData.forEach((skill) => {
              const name = skill["Skill Name"];
              skillDeps.set(
                name,
                skill["Skill Prerequisite"] !== "-"
                  ? skill["Skill Prerequisite"].split(" (")[0]
                  : null
              );
            });

            // Calculate levels based on prerequisites
            const calculateLevel = (skillName, visited = new Set()) => {
              if (visited.has(skillName)) return 0; // Handle circular dependencies
              visited.add(skillName);

              const prereq = skillDeps.get(skillName);
              if (!prereq) return 0;

              return 1 + calculateLevel(prereq, visited);
            };

            // Assign levels to all skills
            skillsData.forEach((skill) => {
              const level = calculateLevel(skill["Skill Name"]);
              skillLevels.set(skill["Skill Name"], level);
            });

            // Group skills by level
            const skillsByLevel = new Map();
            skillLevels.forEach((level, name) => {
              if (!skillsByLevel.has(level)) {
                skillsByLevel.set(level, []);
              }
              skillsByLevel.get(level).push(name);
            });

            // Calculate positions and create skills
            skillsData.forEach((skillData, index) => {
              let x, y;

              if (skillData["Skill Position"]) {
                const posMatch = skillData["Skill Position"].match(/\((\d+),\s*(\d+)\)/);
                x = parseInt(posMatch[1]);
                y = parseInt(posMatch[2]);
              } else {
                const level = skillLevels.get(skillData["Skill Name"]);
                const skillsAtLevel = skillsByLevel.get(level);
                const indexAtLevel = skillsAtLevel.indexOf(skillData["Skill Name"]);

                // Adjust x position to start more to the left
                x = level; // Removed the +1 to start from 0
                y = indexAtLevel + 1;
              }

              // Adjust starting position and spacing based on viewport width
              const isMobile = window.innerWidth <= 768;
              const startX = isMobile
                ? -40 + (window.innerWidth * 3) / 4
                : this.config.grid.startX + (3 / 4) * window.innerWidth;
              const spacing = isMobile ? 100 : this.config.grid.spacing;
              const verticalOffset = 40 + (window.innerHeight * 3) / 4;

              const initialX = startX + x * spacing;
              const initialY =
                this.config.grid.startY + (y - 1) * this.config.grid.spacing + verticalOffset;
              const snappedPos = this.snapToGrid(initialX, initialY);

              const skill = {
                id: ++this.skillIdCounter,
                name: skillData["Skill Name"],
                x: snappedPos.x,
                y: snappedPos.y,
                showActions: false,
                level: skillData["Skill Level"],
                // damage: skillData["Skill Damage"],
                description: skillData["Skill Description"],
                maxPoints: skillData["Skill Max Points"] || this.defaultMaxPoints,
                currentPoints: index < 4 ? 1 : skillData["Skill Current Points"] || 0,
                requiredPoints: skillData["Required Points"] || 0,
                image: `${this.config.paths.images.skills}${skillData["Skill Image"]}`,
                shouldAnimate: false,
                resources: skillData["Skill Resources"] || [],
              };

              // Add damage to resources if it exists
              if (skillData["Skill Damage"]) {
                skill.resources.push({
                  name: "Damage",
                  value: skillData["Skill Damage"],
                  color: "#ff4747",
                });
              }
              this.skills.push(skill);

              // Create connections
              if (skillData["Skill Prerequisite"] !== "-") {
                const prereqName = skillData["Skill Prerequisite"].split(" (")[0];
                const prereqSkill = this.skills.find((s) => s.name === prereqName);
                if (prereqSkill) {
                  this.connections.push({
                    id: `${prereqSkill.id}-${skill.id}`,
                    from: prereqSkill.id,
                    to: skill.id,
                  });
                }
              }
            });

            // Trigger animations with a slight delay for each skill
            setTimeout(() => {
              this.skills.forEach((skill, index) => {
                setTimeout(() => {
                  skill.shouldAnimate = true;
                }, index * 50); // 50ms delay between each skill
              });
            }, 100); // Initial delay of 100ms
          },

          handleTreeTouchStart(event) {
            if (event.touches.length === 1) {
              const touch = event.touches[0];
              this.isPanning = true;
              this.panStart = {
                x: touch.clientX - this.treePosition.x,
                y: touch.clientY - this.treePosition.y,
              };
              this.touchStartX = touch.clientX;
              this.touchStartY = touch.clientY;

              // Cancel any ongoing drag operations when panning starts
              if (this.draggedSkill) {
                this.stopDrag();
              }
            }
          },

          handleTreeTouchMove(event) {
            if (!this.isPanning || event.touches.length !== 1) return;

            const touch = event.touches[0];
            const deltaX = touch.clientX - this.touchStartX;
            const deltaY = touch.clientY - this.touchStartY;

            // Update all skill positions
            this.skills.forEach((skill) => {
              skill.x += deltaX;
              skill.y += deltaY;
            });

            // Force grid recomputation
            if (this.showGlobalGrid) {
              this.$forceUpdate();
            }

            this.touchStartX = touch.clientX;
            this.touchStartY = touch.clientY;
          },

          handleTreeTouchEnd() {
            this.isPanning = false;
            this.touchStartX = null;
            this.touchStartY = null;
          },

          getTooltipPosition(skill) {
            // Get the center position of the skill relative to the viewport
            const skillCenter = skill.x + 30; // 30 is half the skill width
            const viewportCenterOld = window.innerWidth / 2;

            const viewportCenter = this.getAdjustedCoordinates(viewportCenterOld, 0, this.scale).x;
            // If skill is in the right half of the screen, show tooltip on the left
            // Otherwise, show it on the right
            return skillCenter > viewportCenter ? "tooltip-left" : "tooltip-right";
          },

          generateTreeFromPrompt() {
            this.isLoading = true;
            const userPrompt = this.inputText;
            const talentTree = document.querySelector(".talent-tree");

            if (talentTree) {
              talentTree.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 1.9)), ${
                talentTree.style.backgroundImage.split("linear-gradient")[1]
              }`;
            }

            // Clear any future history states if we're not at the end
            if (this.historyIndex < this.history.length - 1) {
              this.history = this.history.slice(0, this.historyIndex + 1);
            }

            // Check if we're in local development
            if (window.location.href.includes("127.0.0.1")) {
              // Load test.json instead
              fetch("/src/app/config/test.json")
                .then((response) => response.json())
                .then((data) => {
                  this.handleGeneratedData(data);
                })
                .catch((error) => {
                  this.handleGenerationError(error);
                });
            } else {
              // Original API endpoint logic
              fetch("/generate_tree_from_prompt_old", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ userPrompt: userPrompt }),
              })
                .then((response) => response.json())
                .then((data) => {
                  this.handleGeneratedData(data);
                })
                .catch((error) => {
                  this.handleGenerationError(error);
                });
            }
          },

          // Add these helper methods to handle the response
          handleGeneratedData(data) {
            const talentTree = document.querySelector(".talent-tree");
            this.treePosition = { x: 0, y: 0 };
            this.scale = 1;

            if (talentTree) {
              talentTree.style.filter = "blur(10px)";

              const img = new Image();
              img.onload = () => {
                setTimeout(() => {
                  talentTree.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.85)), url('${
                    CONFIG.paths.images.backgrounds
                  }${this.parseBackgroundImage(data["Class Image"])}')`;
                  talentTree.style.filter = "blur(0)";
                }, 100);
              };
              img.src =
                CONFIG.paths.images.backgrounds + this.parseBackgroundImage(data["Class Image"]);
            }

            this.loadSkillsFromData(this.parseSkills(data["Skills"]));
            this.currentBackgroundLink =
              CONFIG.paths.images.backgrounds + this.parseBackgroundImage(data["Class Image"]);
            this.currentName = data["Class Name"];
            this.currentClassDescription = data["Class Description"];
            this.isLoading = false;

            // Save to history after loading
            setTimeout(() => {
              this.saveToHistory();
              this.historyIndex = this.history.length - 1;
            }, 1000);
          },

          handleGenerationError(error) {
            console.error("Error generating skill tree:", error);
            this.isLoading = false;
            this.currentName = "Prompt idea didn't work, please try another.";
            const talentTree = document.querySelector(".talent-tree");
            if (talentTree) {
              talentTree.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), ${
                talentTree.style.backgroundImage.split("linear-gradient")[1]
              }`;
              talentTree.style.filter = "blur(0)";
            }
          },

          // Add the parsing functions
          parseSkills(skills) {
            let validImagesString =
              "/axe-hammer-grey.png, /fire-orb.png, /fire-rock.png, /flaming-spear.png, /flaming-staff.png, /golden-arrow.png, /gray-spear.png, /ornate-spear.png, /skull-blue.png, /small-trident.png, /spectral-dagger.png, /water-sword.png";
            validImagesString = validImagesString.replace("/", "");
            const validImagesList = validImagesString.split(", /");
            const defaultImageString = "/fire-rock.png";

            return skills.map((skill) => {
              const skillImage = skill["Skill Image"].replace("/", "");
              if (!validImagesList.includes(skillImage)) {
                skill["Skill Image"] = defaultImageString;
              }
              return skill;
            });
          },

          parseBackgroundImage(backgroundImage) {
            let validImagesString =
              "/grass-ancient.jpg, /desert-academy-ruins.jpg, /purple-spectral-rocks.png";
            validImagesString = validImagesString.replace("/", "");
            const validImagesList = validImagesString.split(", /");
            const defaultImageString = "/grass-ancient.jpg";

            return validImagesList.includes(backgroundImage) ? backgroundImage : defaultImageString;
          },

          saveToHistory() {
            // Don't save if there's no skills (prevents empty initial state)
            if (!this.skills || this.skills.length === 0) {
              return;
            }

            // Remove any future states if we're not at the end of history
            if (this.historyIndex < this.history.length - 1) {
              this.history = this.history.slice(0, this.historyIndex + 1);
            }

            // Create a deep copy of the current state
            const state = {
              skills: JSON.parse(JSON.stringify(this.skills)),
              connections: JSON.parse(JSON.stringify(this.connections)),
              currentName: this.currentName,
              currentBackgroundLink: this.currentBackgroundLink,
              skillIdCounter: this.skillIdCounter,
              timestamp: new Date().toISOString(),
              maxPoints: this.maxPoints,
              currentClassDescription: this.currentClassDescription,
              overlayColor: this.overlayColor,
              overlayOpacity: this.overlayOpacity,
            };

            // Only add state if it's different from the previous state
            const previousState = this.history[this.history.length - 1];
            if (!previousState || JSON.stringify(previousState) !== JSON.stringify(state)) {
              this.history.push(state);

              // Remove oldest state if we exceed maxHistorySize
              if (this.history.length > this.maxHistorySize) {
                this.history.shift();
                this.historyIndex = Math.max(0, this.historyIndex - 1);
              } else {
                this.historyIndex++;
              }
            }
          },

          undo() {
            if (!this.canUndo) {
              console.warn("Undo blocked: canUndo is false");
              return;
            }

            const previousState = this.history[this.historyIndex - 1];

            if (!previousState || !previousState.skills || previousState.skills.length === 0) {
              console.warn("Invalid previous state:", previousState);
              return;
            }

            console.log("Restoring to state:", previousState);
            this.historyIndex--;
            this.restoreState(previousState);
          },

          redo() {
            if (this.canRedo) {
              this.historyIndex++;
              this.restoreState(this.history[this.historyIndex]);
            }
          },

          restoreState(state) {
            this.skills = JSON.parse(JSON.stringify(state.skills));
            this.connections = JSON.parse(JSON.stringify(state.connections));
            this.currentName = state.currentName;
            this.currentClassDescription = state.currentClassDescription;
            this.skillIdCounter = state.skillIdCounter;
            this.currentBackgroundLink = state.currentBackgroundLink;
            this.maxPoints = state.maxPoints;
            this.overlayColor = state.overlayColor;
            this.overlayOpacity = state.overlayOpacity;

            // Update background
            this.updateBackground();
          },

          handleEnterKey(event) {
            // Prevent action if already loading or input is empty
            if (this.isLoading || !this.inputText.trim()) {
              return;
            }

            // Prevent default to avoid any potential form submission
            event.preventDefault();

            // Call generate function
            this.generateTreeFromPrompt();
          },

          showGenerateTooltip(event, text) {
            if (!("ontouchstart" in window)) {
              const tooltip = document.createElement("div");
              tooltip.className = "action-btn-tooltip generate-tooltip";
              tooltip.textContent = text;
              event.target.appendChild(tooltip);
            }
          },

          hideGenerateTooltip(event) {
            const tooltip = event.target.querySelector(".generate-tooltip");
            if (tooltip) {
              tooltip.remove();
            }
          },

          openImageSelector() {
            this.showImageSelector = true;
            // Find the current image in allImages
            const currentImage = this.allImages.find((img) => img.src === this.editingSkill.image);
            this.selectedImage = currentImage ? currentImage.id : null;
          },

          selectImage(image) {
            this.selectedImage = image.id;
            // Use the image src directly instead of trying to construct a path
            this.editingSkill.image = image.src;
          },

          saveImageSelection() {
            // Don't modify the image path - use it as is
            this.editingSkill.image = this.editingSkill.image;
            this.showImageSelector = false;

            // Add a class to temporarily disable the tooltip
            const previewEl = document.querySelector(".skill-preview");
            if (previewEl) {
              previewEl.classList.add("hide-tooltip");
            }
          },

          cancelImageSelection() {
            this.showImageSelector = false;
            this.selectedImage = null;
          },

          loadTreeById(treeId) {
            fetch(`/api/tree/${treeId}`, {
              headers: {
                Accept: "application/json",
              },
            })
              .then((response) => response.json())
              .then((data) => {
                if (data.error) {
                  console.error("Error loading tree:", data.error);
                  return;
                }

                // Restore the tree state
                this.skills = data.skills;
                this.connections = data.connections;
                this.currentName = data.currentName;
                this.currentBackgroundLink = data.currentBackgroundLink;
                this.skillIdCounter = data.skillIdCounter;

                if (data.name) {
                  document.title = `${data.name} | RPG Skill Tree Maker`;
                  const metaDescription = document.querySelector('meta[name="description"]');
                  if (metaDescription) {
                    metaDescription.setAttribute(
                      "content",
                      `Check out this ${data.name} skill tree created with RPG Skill Tree Maker. You can view or customize it in a drag and drop editor, or download the JSON file.`
                    );
                  }
                }

                // Update background
                const talentTree = document.querySelector(".talent-tree");
                if (talentTree) {
                  talentTree.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.85)), url('${this.currentBackgroundLink}')`;
                }

                // Mark tree as loaded
                setTimeout(() => {
                  talentTree.classList.add("loaded");
                }, 100);
              })
              .catch((error) => console.error("Error loading tree:", error));
          },

          shareTree() {
            const state = {
              skills: this.skills,
              connections: this.connections,
              currentName: this.currentName,
              currentBackgroundLink: this.currentBackgroundLink,
              skillIdCounter: this.skillIdCounter,
              timestamp: new Date().toISOString(),
              id: crypto.randomUUID(),
            };

            fetch("/save_tree", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify(state),
            })
              .then((response) => response.json())
              .then((data) => {
                const shareableUrl = `${window.location.origin}/tree/${state.id}?mode=view`;

                const modal = document.createElement("div");
                modal.className = "share-modal";
                modal.innerHTML = `
                                            <button class="close-btn">âœ•</button>
                                            <h3>Share Your Skill Tree</h3>
                                            <div class="share-link">${shareableUrl}</div>
                                            <button class="copy-btn" onclick="navigator.clipboard.writeText('${shareableUrl}').then(() => this.textContent = 'Copied!').catch(() => this.textContent = 'Failed to copy')">
                                                Copy Link
                                            </button>
                                        `;
                document.body.appendChild(modal);

                // Update click handler to include close button
                const removeModal = (e) => {
                  if (e.target === modal || e.target.classList.contains("close-btn")) {
                    document.body.removeChild(modal);
                    document.removeEventListener("click", removeModal);
                  }
                };
                document.addEventListener("click", removeModal);

                // Add specific handler for close button
                const closeBtn = modal.querySelector(".close-btn");
                closeBtn.addEventListener("click", () => {
                  document.body.removeChild(modal);
                  document.removeEventListener("click", removeModal);
                });
              })
              .catch((error) => console.error("Error sharing tree:", error));
          },
          importFromJson() {
            // Create file input element
            const fileInput = document.createElement("input");
            fileInput.type = "file";
            fileInput.accept = ".json";

            fileInput.onchange = (e) => {
              const file = e.target.files[0];
              const reader = new FileReader();

              reader.onload = (event) => {
                try {
                  const data = JSON.parse(event.target.result);

                  // Reset tree position and scale
                  this.treePosition = { x: 0, y: 0 };
                  this.scale = 1;

                  // Check if we have the full data state
                  if (data.FullData) {
                    this.showLoadModal = true;
                    this.loadedData = data;
                    //  Do loading from view modal buttons
                  } else {
                    // Fallback to original import logic

                    // Load the skills using existing loadSkillsFromData method
                    this.loadSkillsFromData(data.Skills);

                    // Update background if provided
                    if (data["Class Image"]) {
                      const talentTree = document.querySelector(".talent-tree");
                      if (talentTree) {
                        talentTree.style.filter = "blur(10px)";

                        const img = new Image();
                        img.onload = () => {
                          setTimeout(() => {
                            talentTree.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, 0.65), rgba(0, 0, 0, 0.85)), url('${
                              this.config.paths.images.backgrounds
                            }${this.parseBackgroundImage(data["Class Image"])}')`;
                            talentTree.style.filter = "blur(0)";
                          }, 100);
                        };
                        img.src =
                          this.config.paths.images.backgrounds +
                          this.parseBackgroundImage(data["Class Image"]);
                        this.currentBackgroundLink =
                          this.config.paths.images.backgrounds +
                          this.parseBackgroundImage(data["Class Image"]);
                      }
                    }

                    // Update class name if provided
                    if (data["Class Name"]) {
                      this.currentName = data["Class Name"];
                    }

                    // Update class description if provided
                    if (data["Class Description"]) {
                      this.currentClassDescription = data["Class Description"];
                    }

                    // Save to history after loading
                    setTimeout(() => {
                      this.saveToHistory();
                    }, 1000);
                  }
                } catch (error) {
                  console.error("Error parsing JSON:", error);
                  alert("Invalid JSON file format");
                }
              };

              reader.readAsText(file);
            };

            // Trigger file input click
            fileInput.click();
          },
          updateSkillShape() {
            document.body.classList.remove("square-skills", "diamond-skills", "hexagon-skills");
            if (this.skillShape !== "round") {
              document.body.classList.add(`${this.skillShape}-skills`);
            }
          },
          loadCustomImages() {
            const savedImages = localStorage.getItem("customImages");
            if (savedImages) {
              this.customImages = JSON.parse(savedImages);
            }
          },
          handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
              const newImage = {
                id: "custom-" + Date.now(),
                src: e.target.result, // This is the base64 data URL
                name: file.name,
                isDefault: false,
              };

              // Add to custom images array
              this.customImages.push(newImage);

              // Save to localStorage
              localStorage.setItem("customImages", JSON.stringify(this.customImages));

              // Automatically select the newly uploaded image
              this.selectImage(newImage);
            };

            reader.readAsDataURL(file);
          },
          openDiscord() {
            window.open("https://discord.gg/VQy45jAhFP", "_blank");
          },
          isViewMode() {
            return this.mode === "view";
          },
          handleModeChange() {
            const url = new URL(window.location);
            this.mode === "view"
              ? url.searchParams.set("mode", "view")
              : url.searchParams.delete("mode");
            window.history.pushState({}, "", url);
            document.body.classList.toggle("view-mode", this.mode === "view");

            if (this.mode === "view") {
              this.showGlobalGrid = false;
              this.skills.forEach((s) => {
                s.showActions = false;
              });
            } else {
              this.showGlobalGrid = true;
            }
          },
          updateBackground() {
            const tree = document.querySelector(".talent-tree");
            if (tree) {
              tree.style.backgroundImage = `linear-gradient(rgba(${parseInt(
                this.overlayColor.slice(1, 3),
                16
              )}, ${parseInt(this.overlayColor.slice(3, 5), 16)}, ${parseInt(
                this.overlayColor.slice(5, 7),
                16
              )}, ${this.overlayOpacity / 100}), rgba(${parseInt(
                this.overlayColor.slice(1, 3),
                16
              )}, ${parseInt(this.overlayColor.slice(3, 5), 16)}, ${parseInt(
                this.overlayColor.slice(5, 7),
                16
              )}, ${this.overlayOpacity / 100})), url('${this.currentBackgroundLink}')`;
            }
          },
          removeConnection(connection) {
            if (this.isViewMode()) return; // Don't remove connections in view mode
            this.connections = this.connections.filter((c) => c.id !== connection.id);
            this.saveToHistory();
          },
          dragStart(e, fromIndex) {
            e.dataTransfer.setData("index", fromIndex);
          },

          drop(e, toIndex) {
            const fromIndex = e.dataTransfer.getData("index");
            const resources = [...this.editingSkill.resources];
            const [resource] = resources.splice(fromIndex, 1);
            resources.splice(toIndex, 0, resource);
            this.editingSkill.resources = resources;
          },
          snapToGrid(x, y) {
            const size = parseInt(this.gridSize) / 2; // Use half the grid size for center points
            const offsetX = this.treePosition.x % (size * 2);
            const offsetY = this.treePosition.y % (size * 2);

            const gridOffset = size / 2;
            // Adjust position by grid size and offset, then subtract skill offset
            return {
              x: Math.round((x - offsetX + gridOffset / 2) / size) * size + offsetX - 30,
              y: Math.round((y - offsetY + gridOffset / 2) / size) * size + offsetY - 30,
            };
          },
          canAddPoint(skill) {
            // Check if adding a point would exceed max points
            if (this.totalPointsSpent >= this.maxPoints) {
              return false;
            }

            // Check if required points are met
            if (skill.requiredPoints && this.totalPointsSpent < skill.requiredPoints) {
              // Create and show toast notification
              const toast = document.createElement("div");
              toast.className = "toast-notification";
              toast.textContent = `${skill.name} requires ${skill.requiredPoints} points spent. Current: ${this.totalPointsSpent}`;
              document.body.appendChild(toast);

              // Trigger reflow to ensure animation plays
              toast.offsetHeight;
              toast.classList.add("show");

              // Remove toast after animation
              setTimeout(() => {
                toast.classList.remove("show");
                setTimeout(() => toast.remove(), 300); // Remove after fade out
              }, 2000);
              return false;
            }

            // Check if skill has required points
            if (skill.damage) {
              // Using old damage field for required points
              const requiredPoints = parseInt(skill.damage);
              if (!isNaN(requiredPoints) && this.totalPointsSpent < requiredPoints) {
                return false;
              }
            }
            // Check prerequisites (incoming connections)
            const incomingConnections = this.connections.filter((conn) => conn.to === skill.id);
            if (incomingConnections.length > 0) {
              if (this.prerequisiteMode === "none") {
                return true;
              } else if (this.prerequisiteMode === "all") {
                // Check if ALL prerequisite skills are unlocked
                const allPrereqsUnlocked = incomingConnections.every((conn) => {
                  const prereqSkill = this.skills.find((s) => s.id === conn.from);
                  return prereqSkill && prereqSkill.currentPoints > 0;
                });

                if (!allPrereqsUnlocked) {
                  // Show toast notification for prerequisite requirement
                  const toast = document.createElement("div");
                  toast.className = "toast-notification";

                  // Get list of missing prerequisites
                  const missingPrereqs = incomingConnections
                    .filter((conn) => {
                      const prereqSkill = this.skills.find((s) => s.id === conn.from);
                      return !prereqSkill || prereqSkill.currentPoints === 0;
                    })
                    .map((conn) => {
                      const prereqSkill = this.skills.find((s) => s.id === conn.from);
                      return prereqSkill.name;
                    })
                    .join(", ");

                  toast.textContent = `${skill.name} requires: ${missingPrereqs} to unlock`;
                  document.body.appendChild(toast);

                  toast.offsetHeight;
                  toast.classList.add("show");

                  setTimeout(() => {
                    toast.classList.remove("show");
                    setTimeout(() => toast.remove(), 300);
                  }, 3000);
                  return false;
                }
              } else {
                // 'one'
                // Check if at least one prerequisite skill is unlocked
                const hasUnlockedPrereq = incomingConnections.some((conn) => {
                  const prereqSkill = this.skills.find((s) => s.id === conn.from);
                  return prereqSkill && prereqSkill.currentPoints > 0;
                });

                if (!hasUnlockedPrereq) {
                  const prereqSkills = incomingConnections
                    .map((conn) => {
                      const prereqSkill = this.skills.find((s) => s.id === conn.from);
                      return prereqSkill.name;
                    })
                    .join(" or ");

                  // Show toast notification for prerequisite requirement
                  const toast = document.createElement("div");
                  toast.className = "toast-notification";
                  toast.textContent = `${skill.name} requires: ${prereqSkills} to unlock`;

                  document.body.appendChild(toast);

                  toast.offsetHeight;
                  toast.classList.add("show");

                  setTimeout(() => {
                    toast.classList.remove("show");
                    setTimeout(() => toast.remove(), 300);
                  }, 3000);
                  return false;
                }
              }
            }

            return true;
          },
          toggleSkillSelection(skill) {
            //  if n
            if (!skill.showActions) {
              skill.showActions = true;
              this.selectedSkills.push(skill);
            } else {
              skill.showActions = false;
              const index = this.selectedSkills.indexOf(skill.id);
              this.selectedSkills.splice(index, 1);
            }
            // if (index === -1) {

            // } else {
            // }

            console.log("selectedSkills", this.selectedSkills);
          },
          loadTree(mode) {
            if (mode === "overwrite") {
              // Import using full data state
              Object.keys(this.loadedData.FullData).forEach((key) => {
                if (key === "loadedData") {
                  return;
                }
                console.log("loading for key", key);
                this[key] = this.loadedData.FullData[key];
              });
              this.updateBackground();
            } else if (mode === "merge") {
              const offset = 0; // Increased offset for better visibility
              const idMap = {};

              // Handle both full data export and regular skill data formats
              const skillsToMerge = this.loadedData.FullData?.skills || this.loadedData.Skills;

              // First pass: Create all skills with new IDs and positions
              skillsToMerge.forEach((skillData) => {
                const newId = ++this.skillIdCounter;

                // Handle different data formats
                const skill = this.loadedData.FullData?.skills
                  ? {
                      ...skillData,
                      id: newId,
                      x: skillData.x + offset,
                      y: skillData.y + offset,
                      showActions: false,
                      shouldAnimate: true,
                    }
                  : {
                      id: newId,
                      name: skillData["Skill Name"],
                      x:
                        this.config.grid.startX +
                        parseInt(skillData["Skill Position"].match(/\((\d+)/)[1]) *
                          this.config.grid.spacing +
                        offset,
                      y:
                        this.config.grid.startY +
                        parseInt(skillData["Skill Position"].match(/,\s*(\d+)/)[1]) *
                          this.config.grid.spacing +
                        offset,
                      description: skillData["Skill Description"],
                      maxPoints: skillData["Skill Max Points"] || this.defaultMaxPoints,
                      currentPoints: skillData["Skill Current Points"] || 0,
                      image: `${this.config.paths.images.skills}${skillData["Skill Image"]}`,
                      showActions: false,
                      shouldAnimate: true,
                      resources: skillData["Skill Resources"] || [],
                    };

                // Store the mapping of old ID to new ID
                idMap[skillData.id || skillData["Skill Name"]] = newId;
                this.skills.push(skill);
              });

              // Second pass: Create connections with updated IDs
              if (this.loadedData.FullData?.connections) {
                // Handle full data export connections
                this.loadedData.FullData.connections.forEach((conn) => {
                  this.connections.push({
                    id: `${idMap[conn.from]}-${idMap[conn.to]}`,
                    from: idMap[conn.from],
                    to: idMap[conn.to],
                  });
                });
              } else {
                // Handle regular skill data connections
                skillsToMerge.forEach((skillData) => {
                  if (skillData["Skill Prerequisite"] && skillData["Skill Prerequisite"] !== "-") {
                    const prereqName = skillData["Skill Prerequisite"].split(" (")[0];
                    const fromId = idMap[prereqName];
                    const toId = idMap[skillData["Skill Name"]];

                    if (fromId && toId) {
                      this.connections.push({
                        id: `${fromId}-${toId}`,
                        from: fromId,
                        to: toId,
                      });
                    }
                  }
                });
              }

              // Trigger animations for new skills
              setTimeout(() => {
                this.skills.forEach((skill) => {
                  if (skill.id > this.skillIdCounter - skillsToMerge.length) {
                    skill.shouldAnimate = true;
                  }
                });
              }, 100);
            }

            this.showLoadModal = false;

            setTimeout(() => {
              this.saveToHistory();
              this.loadedData = null;
            }, 1000);
          },
          handleBackgroundUpload(event) {
            const file = event.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (e) => {
                const imageData = {
                  id: `bg_${Date.now()}`,
                  src: e.target.result,
                  name: file.name,
                  type: "background",
                };

                // Update recent backgrounds
                this.recentBackgrounds.unshift(imageData);
                // Keep only the 3 most recent
                this.recentBackgrounds = this.recentBackgrounds.slice(0, 3);
                // Save to localStorage
                localStorage.setItem("recentBackgrounds", JSON.stringify(this.recentBackgrounds));

                // Save to localStorage
                const customImages = JSON.parse(localStorage.getItem("customImages") || "[]");
                customImages.push(imageData);
                localStorage.setItem("customImages", JSON.stringify(customImages));

                // Update background
                this.currentBackgroundLink = imageData.src;
                this.updateBackground();
              };
              reader.readAsDataURL(file);
            }
          },

          // updateBackground() {
          //     const talentTree = document.querySelector('.talent-tree');
          //     if (talentTree && this.currentBackgroundLink) {
          //         talentTree.style.backgroundImage = `linear-gradient(rgba(0, 0, 0, ${this.overlayOpacity / 100}), rgba(0, 0, 0, ${this.overlayOpacity / 100})), url('${this.currentBackgroundLink}')`;
          //     }
          // },

          // Add these new methods
          handleSelection(eventOld) {
            // Check if we're interacting with a skill or other UI element
            if (!eventOld.target) {
              // event.target.classList is undefined if dragged off screen. maybe use this to shift the view
              return;
            }
            let adjustedCoordinates = this.getAdjustedCoordinates(
              eventOld.clientX,
              eventOld.clientY,
              this.scale
            );
            let event = {
              clientX: adjustedCoordinates.x,
              clientY: adjustedCoordinates.y,
              offsetX: adjustedCoordinates.x,
              offsetY: adjustedCoordinates.y,
            };

            const moveThreshold = 5; // pixels
            const deltaX = event.offsetX - this.initialClick.x;
            const deltaY = event.offsetY - this.initialClick.y;

            if (Math.abs(deltaX) > moveThreshold || Math.abs(deltaY) > moveThreshold) {
              // Create selection box on first movement
              this.selectionBox = {
                x: this.initialClick.x,
                y: this.initialClick.y,
                width: 0,
                height: 0,
              };
            }

            if (this.selectionBox) {
              this.selectionBox.width = event.offsetX - this.selectionBox.x;
              this.selectionBox.height = event.offsetY - this.selectionBox.y;

              // Select skills within box
              // Select skills within box and set showActions
              this.selectedSkills = this.skills.filter((skill) => {
                const box = {
                  left: Math.min(
                    this.selectionBox.x,
                    this.selectionBox.x + this.selectionBox.width
                  ),
                  right: Math.max(
                    this.selectionBox.x,
                    this.selectionBox.x + this.selectionBox.width
                  ),
                  top: Math.min(
                    this.selectionBox.y,
                    this.selectionBox.y + this.selectionBox.height
                  ),
                  bottom: Math.max(
                    this.selectionBox.y,
                    this.selectionBox.y + this.selectionBox.height
                  ),
                };
                const isSelected =
                  skill.x + 30 >= box.left &&
                  skill.x + 30 <= box.right &&
                  skill.y + 30 >= box.top &&
                  skill.y + 30 <= box.bottom;

                skill.showActions = isSelected;
                return isSelected;
              });
            }
          },

          stopSelection() {
            if (this.selectionBox) {
              setTimeout(() => {
                this.selectionBox = null;
              }, 100);
            }

            document.removeEventListener("mousemove", this.handleSelection);
            document.removeEventListener("mouseup", this.stopSelection);
            // Keep the selection but remove the box
          },
          deselectAllSkills() {
            // Clear all existing selections and action menus
            this.selectedSkills = [];
            this.skills.forEach((s) => {
              s.showActions = false;
            });
          },
          copy() {
            // It seems like this.selectedSkills cannot be accessed here.
            // Possibly due to a scope issue.

            const selectedSkills = this.skills.filter((skill) => skill.showActions);

            if (selectedSkills.length === 0) {
              return;
            } else {
              this.clipboard = selectedSkills;
            }

            console.log("Copied nodes:", this.clipboard);
          },

          paste() {
            this.deselectAllSkills();
            // append "copy" to the skill name
            // adjust positions by a small offset so they are not perfectly overlapping
            // add nodes from clipboard to the state
            // update the selected nodes to be the newly pasted ones

            if (this.clipboard.length === 0) {
              return;
            }

            // Deep copy the clipboard nodes
            const copiedNodes = JSON.parse(JSON.stringify(this.clipboard));
            // Calculate grid-based offset
            const gridOffset = this.showGlobalGrid ? parseInt(this.gridSize) : 120; // Use grid size if enabled, otherwise default to 120px

            // Update copied nodes
            copiedNodes.forEach((node) => {
              node.id = ++this.skillIdCounter;
              node.x += gridOffset / 2;
              node.y += gridOffset / 2;
              node.showActions = true;
              node.shouldAnimate = true;
              node.name += " copy";
            });

            // Add copied nodes to the state
            this.selectedSkills = copiedNodes;
            this.skills.push(...copiedNodes);
            this.saveToHistory();
          },
          handleResize() {
            // Force recomputation of grid lines
            this.gridSize = window.innerWidth <= 768 ? 80 : 120;

            const zoomTree = document.querySelector(".zoom-tree");
            if (zoomTree) {
              zoomTree.style.width = `${window.innerWidth * 2}px`;
              zoomTree.style.height = `${window.innerHeight * 2}px`;
            }

            if (this.showGlobalGrid) {
              // Update the tree position slightly to force reactivity
              this.treePosition = {
                x: this.treePosition.x,
                y: this.treePosition.y,
              };

              // Force Vue to recompute the grid lines
              this.$nextTick(() => {
                this.$forceUpdate();
              });
            }
          },
        },
      }).mount("#app");
    </script>
  </body>
</html>
